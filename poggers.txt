Planar Edges
-------------
I literally just browsed this wikipedia page (https://en.wikipedia.org/wiki/Catalan_number) and I saw a familiar problem on the right...
-------------
from math import comb
class Solution:
    def solve(self, n):
        if n&1: return 0
        n //= 2
        return comb(2*n, n) // (n+1) % (10 ** 9 + 7)
Interval Carving
-------------
If our interval intersects with cut, we check if there is a remainder before and after the cut and add it if so. If there's no intersection we just add the intersection.
-------------
class Solution:
    def solve(self, intervals, cut):
        cs,ce=cut
        ans=[]
        for s,e in intervals:
            if max(cs,s)<min(e,ce):
                if s<cs:
                    ans.append([s,cs])
                if e>ce:
                    ans.append([ce,e])
            else:
                ans.append([s,e])
        return ans

Making Change Sequel
-------------
Dynamic programming solution, in cpp because i was timing out in Python.

For each value dp[v], dp[v] = min(dp[v-coin]+1 for each coin)
-------------
#include <bits/stdc++.h>

#include "solution.hpp"
using namespace std;

int Solution::solve(vector<int>& denominations, int amount) {
    int dp[amount + 1];
    dp[0] = 0;
    for (int v = 1; v < amount + 1; v++) {
        dp[v] = 10000000;
    }
    for (int v = 1; v < amount + 1; v++) {
        for (int coin : denominations) {
            if (v - coin >= 0) {
                dp[v] = min(dp[v], dp[v - coin] + 1);
            }
        }
    }
    return dp[amount] < 10000000 ? dp[amount] : -1;
};


int solve(vector<int>& denominations, int amount) {
    return (new Solution())->solve(denominations, amount);
}
Making Change Sequel
-------------
M[i,k] = min(M[i-1,k], M[i,k-denominations[i]] + 1)

Since we copy the previous row of the 2D dp matrix, we can just reuse the same row
-------------
from functools import lru_cache
class Solution:
    def solve(self, denominations, amount):
        dp = [float('inf') for _ in range(amount+1)]
        dp[0]=0
        for d in denominations:
            for i in range(d, len(dp)):
                if dp[i-d] < dp[i]:
                    dp[i] = dp[i-d] + 1
        return dp[-1] if dp[-1] < float('inf') else -1

Interleaved String
-------------
Sexy one-liner. Pair up corresponding characters and pad with empty strings.
-------------
from itertools import zip_longest
class Solution:
    def solve(self, s0, s1):
        return "".join(x+y for x,y in zip_longest(s0,s1,fillvalue=""))

Inorder Traversal
-------------
Oh baby generators are so sexy. ~~~~~~~~~~~~~~~~~~~~~~~~~
-------------
class Solution:
    def solve(self, root):
        return list(it(root))
        
def it(node):
    if not node: return
    yield from it(node.left)
    yield node.val
    yield from it(node.right)

Trimmed Palindromes
-------------
This problem is exactly the same as the number of substring palindrome, because substrings are made from trimming left and right.
-------------
class Solution:
    def solve(self, s):
        c=0
        for i in range(len(s)):
            c+=expand(i,i,s)
            c+=expand(i,i+1,s)
        return c

def expand(i,j,s):
    c=0
    while i>=0 and j<len(s) and s[i]==s[j]:
        i-=1
        j+=1
        c+=1
    return c
Distance Pair
-------------
Alex's answer is more space-efficient, but this helps me to visualize the problem. 

The first step is to reduce the dimensionality of the problem: we can combine nums[i]+i into x and nums[j]-j into y, so now we only have to maximize the sum of x[i] + y[j], i<j.

From a position x[i], we can pick any y[j] where j>i, but we are only interested in the maximal y[j] where j is greater than i. So instead of containing every individual value, each index in y will hold the maximal value to the right of the position y[j].

So then, we can lookup the max y[j] for i<j in constant time, while iterating over every possible x[i].
-------------
class Solution:
    def solve(self, nums):
        x=[i+nums[i] for i in range(len(nums))]
        y=[nums[j]-j for j in range(len(nums))]
        for i in range(len(y)-2,-1,-1):
            y[i] = max(y[i], y[i+1])
        a=0
        for i in range(len(x)-1):
            a=max(a,x[i]+y[i+1])
        return a
            
                

Big Numbers
-------------
We calculate the max of each row and of each column, and check if both are equal to the cell for any position.

zip(*matrix) is a cool trick that will transpose your matrix.
-------------
class Solution:
    def solve(self, matrix):
        transpose = zip(*matrix)
        maxr = [max(row) for row in matrix]
        maxc = [max(col) for col in transpose]
        return sum(matrix[i][j] == maxr[i] == maxc[j] 
                for j in range(len(matrix[0]))
                for i in range(len(matrix))
            )

First Missing Positive
-------------
O(n) time, O(n) space solution.

Create a set from all numbers. Start from one, and increment each time you find the value in the set. 

O(1) space is possible:
https://www.geeksforgeeks.org/find-the-smallest-positive-number-missing-from-an-unsorted-array/
-------------
class Solution:
    def solve(self, nums):
        s=set(nums)
        i=1
        while i in s:
            i+=1
        return i

Number of Islands
-------------
We can delete each island using dfs as well.            
-------------
class Solution:
    def solve(self, matrix):
        def remove_island(i,j):
            matrix[i][j]=0
            for di,dj in [(1,0), (-1,0), (0,1), (0,-1)]:
                ni, nj = i+di, j+dj
                if 0<=ni<len(matrix) and 0<=nj<len(matrix[0]) and matrix[ni][nj]:
                    remove_island(ni,nj)
        ans=0
        for i,r in enumerate(matrix):
            for j,v in enumerate(r):
                if v: 
                    ans+=1
                    remove_island(i,j)
        return ans

Shortest Common Supersequence
-------------
This problem can be solved using longest common subsequence:

With:
a = "bell"
b = "yellow"
"ell" is the longest common subsequence, so if we concatenate both strings:
"bellyellow", we can remove the lcs to get "byellow".
-------------
from functools import lru_cache
class Solution:
    def solve(self, a, b):
        @lru_cache(None)
        def lcs(i,j):
            if i==len(a) or j == len(b): return 0
            if a[i]==b[j]:
                return 1 + lcs(i+1,j+1)
            return max(lcs(i+1,j), lcs(i,j+1))
        return len(a)+len(b)-lcs(0,0)

Leftmost Deepest Tree Node
-------------
Visit each node keeping track of depth in-order, if we ever reach a node with a greater depth, we replace the return value.
-------------
class Solution:
    def solve(self, root):
        maxdepth=-1
        maxval=0
        def dfs(node, depth=0):
            nonlocal maxval
            nonlocal maxdepth
            if not node: return
            if depth>maxdepth: 
                maxval=node.val
                maxdepth=depth
            dfs(node.left,depth+1)
            dfs(node.right,depth+1)
        dfs(root)
        return maxval

Longest Tree Path
-------------
One way to do this efficiently is for every node, count the amount of nodes under them in a bottom-up fashion. 

For every node, the longest path going through that node is the deepest from the left to the deepest to the right (plus one, to include the node).
-------------
class Solution:
    def solve(self, root):
        mx=0
        def dfs(node):
            nonlocal mx
            if not node: return 0
            deepest_left=dfs(node.left)
            deepest_right=dfs(node.right)
            mx=max(mx, deepest_left+deepest_right+1)
            return 1+max(deepest_left, deepest_right)
        dfs(root)
        return mx
Rectangular Overlap
-------------
A clearer version. For each dimensions (x,y), check that the max of the start of the interval is less than the min of the end of the intervals.
-------------
class Solution:
    def solve(self, rect0, rect1):
        l0,b0,r0,t0 = rect0
        l1,b1,r1,t1 = rect1
        return max(b0,b1)<min(t0,t1) and max(l0,l1)<min(r0,r1)

Partition Tree
-------------
Alternative solution: we can return two values, the number of leaves and the number of non-leaves. We combine the values from the subtrees and add one when its not a leaf to obtain the answer.
-------------
# class Tree:
#     def __init__(self, val, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def solve(self, root):
        def dfs(node):
            if not node: return 0,0
            if not node.left and not node.right: return 1,0
            l1,nl1 = dfs(node.left)
            l2,nl2 = dfs(node.right)
            return l1+l2, nl1+nl2+1
        return dfs(root)

Palindrome Linked List
-------------
The trick to do this legitimately in constant space is the following.

- Find the middle using slow/fast pointers.
- Reverse the linked list up to the middle.
- Consider the first split behind the half to the left of the middle, and the second split to be the half to the right of the middle. We iterate on both splits as long as values of each split equal each other. If we reach the end, we have a palindrome.
-------------
class Solution:
    def solve(self, node):
        slow=fast=node
        fast=node.next
        while fast and fast.next:
            slow=slow.next
            fast=fast.next.next
        mid=slow
        second_split = mid.next
        prev=None
        cur=node
        while cur != second_split:
            nxt=cur.next
            cur.next=prev
            prev=cur
            cur=nxt
        first_split=prev
        if first_split.val != second_split.val:
            first_split=first_split.next
        while first_split and second_split:
            if first_split.val != second_split.val:
                return False
            first_split=first_split.next
            second_split=second_split.next
        return True

Univalue Tree
-------------
Check that the current node equals its children, then recursively check that the same holds for both children.
-------------
class Solution:
    def solve(self, root):
        if not root: return True
        if root.left and root.left.val != root.val: return False
        if root.right and root.right.val != root.val: return False
        return self.solve(root.left) and self.solve(root.right)

Special Nodes
-------------
We generate a set of colors for every subtree, and return: (the set of colors, if the subtree contains all uniques and the number of uniquely colored subtrees). For a subtree to be uniquely colored, all its children must be uniquely colored and the color of the root node must not be in the set of colors in the child nodes.
-------------
class Solution:
    def solve(self, tree, color):
        seen=set()
        def dfs(node):
            seen.add(node)
            colors=set()
            unique=True
            ans=0
            for nei in tree[node]:
                if nei in seen: continue
                cols,uniq_count,subtree_unique=dfs(nei)
                ans+=uniq_count
                if not unique: continue
                unique &= subtree_unique
                if len(cols&colors)!=0: unique=False
                colors |= cols
            if color[node] in colors:
                unique=False
            else:
                colors.add(color[node])
            if unique: ans+=1
            seen.remove(node)
            return colors,ans,unique
        _,a,_= dfs(0)
        return a

Swap Consecutive Pair of Even Numbers
-------------
We keep track of the last even number, and flip them every 2nd time we see an even number.
-------------
class Solution:
    def solve(self, nums):
        j,flip=0,False
        for i in range(len(nums)):
            if not nums[i]&1:
                if flip: nums[i],nums[j]=nums[j],nums[i]
                j=i
                flip^=True
        return nums

Arithmetic Sequences
-------------
We create an array with the difference of contiguous elements. We group identical chunks of differences together, and we will get the length of the longest arithmetic series of a given difference. To compute the number of arithmetic series greater than 3 in length inside this arithmetic serie, we ironically have to use the arithmetic serie 1+2+...+n. Here's why:

Take: 3,5,7,9,11,12,13
Our differences will be [2,2,2,2,1,1]
We have 4 differences of 2, which means we have a serie of length (4+1).
With 5 elements, we can build one serie of length 5, two series of length 4 and 3 series of length 3. So we have 1+2+3. 

The value of 1+2+..+n is n(n+1)//2. We set n = l-1 and we are golden.
-------------
from itertools import groupby
class Solution:
    def solve(self, nums):
        diff=[nums[i]-nums[i-1] for i in range(1,len(nums))]
        ans=0
        for _, grp in groupby(diff):
            l=len(list(grp))
            if l>1:  ans += l*(l-1)//2
        return ans

Count BST Nodes in a Range
-------------
If the current node is larger than the higher bound of the interval, every value in the interval will be to the left of the current node because they are smaller.

If the current node is smaller than the lower bound of the interval, every value in the interval will be to the right of the current node because they are larger.

Otherwise, the current value is in the interval and values can be on both sides of the current node.
-------------
# class Tree:
#     def __init__(self, val, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def solve(self, root, lo, hi):
        if not root: return 0
        if hi < root.val:
            return self.solve(root.left, lo, hi)
        elif lo >  root.val:
            return self.solve(root.right, lo, hi)
        else:
            return self.solve(root.left, lo, hi) + self.solve(root.right, lo, hi) + 1

123 Number Flip
-------------
Regex one-liner: we replace the first occurence of a non three digit by a 3.
-------------
import re
class Solution:
    def solve(self, n):
      return int(re.sub("[^3]", "3", str(n), 1))
String Sequence
-------------
Constant memory, linear time. We just need to remember the last two elements.
-------------
from collections import deque
class Solution:
    def solve(self, s0, s1, n):
        a=deque([s0,s1])
        if n in (0,1): return a[n]
        for i in range(1,n):
            if i&1:
                a.append(a[-1]+a[-2])
            else:
                a.append(a[-2]+a[-1])
            a.popleft()
        return a[-1]

High Five
-------------
You don't need to think if you try all possibilities :D it's O(n) anyways. 

Just try all possible insertions, note that you can't start at index 0 if its negative because it will put a digit in front of the negative sign.
-------------
class Solution:
    def solve(self, n):
        s=str(n)
        return max(int(s[:i]+"5"+s[i:]) for i in range(n<0,len(s)+1))
Unique Fractions
-------------
Python has inbuilt fractions that simply fractions for you, and are hashable as well.
-------------
from fractions import Fraction as frac
class Solution:
    def solve(self, fractions):
        s=set()
        for num,denum in fractions:
            f=frac(num,denum)
            s.add(f)
        return sorted([[f.numerator, f.denominator] for f in s],key=lambda x: x[0]/x[1])
Subtree
-------------
Alternative solution: we can serialize the tree as a string and check if the target string is in the root string.
-------------
# class Tree:
#     def __init__(self, val, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def solve(self, root, target):
        root=hash(root)
        target=hash(target)
        return target in root

def hash(node):
    a=[str(node.val)]
    if node.left: a.append(hash(node.left))
    if node.right: a.append(hash(node.right))
    return f"({' '.join(a)})"
Points on a Line
-------------
O(N^2) solution: first we sort the points so the slopes are processed in the same relative order for all points.

Then, we iterate over each point, setting them as the relative origin against which we will compute the slope for each point.

For each point, we check all the point to its right - compute the slope (dx/dy). To avoid problems with division by zero, we can simplify leave the fraction under the form of a tuple, simplifying it by dividing by the greatest common divisor of the numerator and denominator. One edge case is 0/0 (two identical points) where the gcd will be 0, then we can use 1 as a gcd instead.

We count the largest amount of points sharing the same slope, relative to a previous point.
-------------
from math import gcd
from collections import defaultdict
class Solution:
    def solve(self, coordinates):
        ans=0
        coordinates.sort()
        for i,(ox,oy) in enumerate(coordinates):
            cnt=defaultdict(int)
            for j in range(i+1, len(coordinates)):
                cx,cy = coordinates[j]
                dx = cx-ox
                dy = cy-oy
                ngcd = max(gcd(dx,dy),1)
                dx //= ngcd
                dy //= ngcd
                cnt[(dx,dy)]+=1
                ans=max(ans,cnt[(dx,dy)])
        return ans+1

Sort by Permutation
-------------
Solution for the lazies like me: create pairs using (p[i], lst[i]), sort them build an array from lst[i].
-------------
class Solution:
    def solve(self, lst, p):
        return [x for _,x in sorted(zip(p,lst))]

Bounce
-------------
For each position, try going both left and right recursively. Keep note of visited positions to avoid going into a cycle. If we reach the final position, return True.
-------------
class Solution:
    def solve(self, nums, k):
        seen=set()
        def dfs(pos):
            if pos in seen: return False
            if pos == len(nums)-1: return True
            seen.add(pos)
            if 0<=pos<len(nums):
                if dfs(pos+nums[pos]): return True
                if dfs(pos-nums[pos]): return True
            return False
        return dfs(k)

Interval Overlaps
-------------
Given two intervals:

There is an intersection if the maximum of their start is smaller or equal to the minimum of their ends. Example:
[---]   [--]
1--4  5--6
max(1,5)=5, min(4,6)=4, hi<lo => no intersection.
[---[--]--]
1--4--5--6
max(1,4)=4, min(5,6)= 5, 5>=4 => intersection from 4 to 5.

Given that the intervals are in sorted order, we can't increase our interval to the left, only to the right, so we discard our interval with the smallest end, since it is encapsulated by the one with the larger end.

https://leetcode.com/problems/interval-list-intersections/solution/


-------------
class Solution:
    def solve(self, A, B):
        ans = []
        i = j = 0

        while i < len(A) and j < len(B):
            # Let's check if A[i] intersects B[j].
            # lo - the startpoint of the intersection
            # hi - the endpoint of the intersection
            lo = max(A[i][0], B[j][0])
            hi = min(A[i][1], B[j][1])
            if lo <= hi:
                ans.append([lo, hi])

            # Remove the interval with the smallest endpoint
            if A[i][1] < B[j][1]:
                i += 1
            else:
                j += 1

        return ans

Z Sum
-------------
We add the sum of the first row and the last row, plus the diagonal in between, making sure to not count the elements in the corner twice.

Edge cases are empty array and matrix of size 1x1.
-------------
class Solution:
    def solve(self, matrix):
        if not matrix: return 0
        if len(matrix)==1: return matrix[0][0]
        return sum(matrix[0]) + sum(matrix[-1]) + \
        sum(matrix[i][~i] for i in range(1,len(matrix)-1))

Tree Sum
-------------
The sum of a tree is the sum of every node and their children.
-------------
class Solution:
    def solve(self, root):
        return root.val + self.solve(root.left) + self.solve(root.right) if root else 0

Number of Hops
-------------
O(n*max(nums)) solution, but with a cheesy optimisation. If dp[j], (the number of hops required to reach nums[j]) is smaller or equal than dp[i], we know everything to the left of it will also be smaller so we don't need to check those values.
-------------
class Solution:
    def solve(self, nums):
        dp=[1e9 for _ in nums]
        dp[0]=0
        for i,n in enumerate(nums):
            for j in range(min(i+nums[i], len(nums)-1), i, -1):
                if dp[j]<=dp[i]+1: break
                dp[j] = dp[i]+1
        return dp[-1]

Longest Interval 
-------------
We sort intervals, and check if the current interval intersects with the previous one, by checking if the start of the current interval comes before the end of the previous one. 

If so, we update the end of the previous one to the max of the ends of the two intervals. We have to take the max because it is possible the current interval is totally contained by the previous, so that its end comes before the end of the previoius.

Then we remove the redundant interval, and check the max delta in intervals.
-------------
class Solution:
    def solve(self, intervals):
        intervals.sort()
        i=1
        while i < len(intervals):
            s,e = intervals[i]
            ps,pe = intervals[i-1]
            if s<=pe:
                intervals[i-1][1]=max(pe, e)
                intervals.pop(i)
            else:
                i+=1
        return max(e-x+1 for x,e in intervals)
String Isomorphism
-------------
Checking for a one-to-one mapping is proving the bijection of a function: https://en.wikipedia.org/wiki/Bijection,\_injection\_and\_surjection.​

To do so, the first check validates that every character in t is only refered once. After that, we check that every character in c only refers to one value in t.

str.maketrans(s,t) automatically creates a mapping between two strings.

​

-------------
class Solution:
    def solve(self, s, t):
        tb="".maketrans(s,t)
        if len(tb.values()) != len(set(tb.values())):
            return False
        if any(tb[ord(c)] != ord(d) for c,d in zip(s,t)):
            return False
        return True
Sum of Four Numbers
-------------
O(n^2) solution

We compute the sum of every possible pair of numbers. Then, we check if the complement if this sum exists in the precomputed sums, and if the numbers are distinct.
-------------
from collections import defaultdict
class Solution:
    def solve(self, nums, k):
        s=defaultdict(list)
        for i in range(len(nums)):
            for j in range(i+1,len(nums)):
               s[nums[i]+nums[j]].append((i,j))
        for i in range(len(nums)):
            for j in range(i+1,len(nums)):
                x=nums[i]+nums[j]
                complement = k-x
                if complement in s:
                    for i2,j2 in s[complement]:
                        if len({i,j,i2,j2})==4:
                            return True
        return False

Linked List Union
-------------
The lazy way is the best way, don't let anyone tell you otherwise.
-------------
class Solution:
    def solve(self, ll0, ll1):
        s=set(it(ll0))|set(it(ll1))
        head=prev=LLNode(None)
        for x in sorted(s):
            prev.next=LLNode(x)
            prev=prev.next
        return head.next
    
def it(n):
    while n:
        yield n.val
        n=n.next

The Accountant
-------------
Undercover base conversion problem. We divide repeatedly by 26 to find the character, subtract one because it is 1-based.
-------------
class Solution:
    def solve(self, n):
        ans=""
        while n:
            n,rem = divmod(n-1,26)
            ans+=chr(rem+ord("A"))
        return ans[::-1]

Unidirectional Word Search
-------------
For every position, we iterate in both directions while the characters from the word and the board match. If we reach the end of the word, we have found it.
-------------
class Solution:
    def solve(self, board, word):
        def dfs(i,j,k,right):
            if k>=len(word): return True
            if i<0 or i>= len(board) or j<0 or j>=len(board[0]) or \
                board[i][j] != word[k]: return False
            if right and dfs(i,j+1,k+1,right): return True
            if not right and dfs(i+1,j,k+1,right): return True
            return False
        for i in range(len(board)):
            for j in range(len(board[0])):
                if dfs(i,j,0,True): return True
                if dfs(i,j,0,False): return True
        return False
            

Corner Diagonals
-------------
If n is even, diagonals don't intersect and they each contain n cells, so we remove from the total number of cells (n*n) the diagonals (2*n).

If n is odd, the diagonals intersect in the center, so in order to not double-count it, we add back one, which gives n*n - 2*n + 1
-------------
class Solution:
    def solve(self, n):
        return n*n-2*n+1 if n&1 else n*n-2*n

Steady Car
-------------
We create a list of speeds by subtracting position i by position i-1. We use groupby to group equal contiguous elements. We return the longest such contiguous group.
-------------
from itertools import groupby
class Solution:
    def solve(self, positions):
        return max(map(lambda x: len(list(x[1])), groupby([abs(positions[i]-positions[i-1]) for i in range(1,len(positions))])))+1

Conway's Game of Life
-------------
This solution focuses on simplicity and not performance. 

Using an in_bounds function can be useful if you want to iterate over the neighbors without worrying about being outside the matrix.
-------------
class Solution:
    def solve(self, matrix):
        next=[[0]*len(matrix[0]) for _ in matrix]
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                neighbor_cnt = 0
                for n1 in range(i-1, i+2):
                    for n2 in range(j-1, j+2):
                        if (n1 != i or n2 != j) and in_bounds(n1,n2, matrix):
                            neighbor_cnt += matrix[n1][n2]
                if matrix[i][j]==1 and neighbor_cnt in [2,3]:
                    next[i][j]=1
                elif matrix[i][j]==0 and neighbor_cnt == 3:
                    next[i][j]=1
        return next
                
def in_bounds(i,j, matrix):
    return i>=0 and j>=0 and i<len(matrix) and j<len(matrix[0])
camelCase
-------------
lowercase the first word, capitalize the rest. ez pz
-------------
class Solution:
    def solve(self, words):
        s=words.pop(0).lower()
        return s+"".join(w.capitalize() for w in words)
        # Write your code here
        

Shortest Bridge
-------------
We iterate over the array to find the first one we see, record its position. Then, we do BFS to find the border of the first island. Finally, we do BFS using the border of the first island to count the number of steps we need to reach the border of the second island.
-------------
from collections import deque
class Solution:
    def solve(self, arr):
        def get_neighbors(i,j):
            for di,dj in [(1,0), (-1,0), (0,1), (0,-1)]:
                ni,nj = i+di, j+dj
                if ni>=0 and nj>=0 and ni<len(arr) and nj<len(arr[0]):
                    yield ni,nj
                    
        start=None
        for i in range(len(arr)):
            for j in range(len(arr[0])):
                if arr[i][j] == 1:
                    start=(i,j)
                    break
        q=deque([start])
        seen=set()
        nseen=set()
        while q:
            i,j = q.popleft()
            if (i,j) in seen: continue
            seen.add((i,j))
            for ni,nj in get_neighbors(i,j):
                if arr[ni][nj] == 0: 
                    nseen.add((i,j))
                else:
                    q.append((ni,nj))
                    
        nq = deque(nseen)
        ans=0
        while nq:
            for _ in range(len(nq)):
                i,j = nq.popleft()
                if ans>0 and arr[i][j] == 1: return ans-1
                for ni,nj in get_neighbors(i,j):
                    if (ni,nj) in seen: continue
                    seen.add((ni,nj))
                    nq.append((ni,nj))
            ans+=1
Candy Race
-------------
Apparently you can solve this in 1ms, but here's a memoized recursive solution for your soul.
-------------
from functools import lru_cache
class Solution:
    def solve(self, candies):
        @lru_cache(None)
        def dfs(i,j):
            if j<i: return 0
            return max(candies[i]-dfs(i+1, j), candies[j]-dfs(i,j-1))
        return dfs(0, len(candies)-1)>0

Sum Tree
-------------
Edge cases:
- null node: nothing is equal to the sum of nothing and nothing, so return True
- Leaves: if no children, return True

Then compute the sum and check that all subnodes respect the constraint.
-------------
class Solution:
    def solve(self, root):
        if not root: return True
        if not root.left and not root.right: return True # leaf
        s=0
        if root.left:
           s+=root.left.val
        if root.right:
           s+=root.right.val
        return s==root.val and self.solve(root.left) and self.solve(root.right)
Bomber Man
-------------
Same logic as alex's answer, but shorter. The number of safe cells is the product of the number of safe rows times the number of safe columns.
-------------
class Solution:
    def solve(self, matrix):
        rows=sum(1 for r in matrix if 1 not in r)
        cols=sum(1 for c in zip(*matrix) if 1 not in c)
        return rows*cols

Unix Path Resolution
-------------
Same as alexwice's answer but with one less newline, therefore it is better.

-------------
class Solution:
    def solve(self, path):
        a=[]
        for x in path:
            if x == "..":
                if a:
                    a.pop()
            elif x != ".":
                a.append(x)
        return a
Revolving Door
-------------
I don't remember what i was doing but it kinda works xDD
-------------
from collections import defaultdict
class Solution:
    def solve(self, requests):
        buckets=defaultdict(lambda: [[], []])
        last=1
        lasttime=-1
        for time, direction in requests:
            buckets[time][direction].append("")
        ans=[]
        for time in sorted(buckets.keys()):
            if time > lasttime:
                last = 1
                lasttime=time
            while buckets[time][last]:
                buckets[time][last].pop()
                ans.append([lasttime, last])
                lasttime+=1
            if buckets[time][last^1]:
                last ^= 1
                while buckets[time][last]:
                    buckets[time][last].pop()
                    ans.append([lasttime, last])
                    lasttime+=1
        return ans
                

Bubble Swap
-------------
Stolen from alexwice, O(n^2)

We sequentially compute the cost of bringing the correct value to the front of the array (which is equal to its position in the array), in an insertion sort fashion.
-------------
class Solution:
    def solve(self, lst0, lst1):
        ans = 0
        for req in lst1:
            i = lst0.index(req)
            lst0.pop(i)
            ans += i
        return ans
Minimum Bracket Addition
-------------
When the bracket running count goes under 0, it means you are closing brackets that were never opened, so with certainty you will need to open it, so it adds one to the answer.

In the other case, you need to close the parentheses that were never closed at the end, so you add the running count.
-------------
class Solution:
    def solve(self, s):
        cnt = ans = 0
        for c in s:
            cnt += ") (".index(c) - 1
            if cnt < 0:
                cnt=0
                ans+=1
        return ans+cnt
Line of People
-------------
If there are at most b people behind you, your position can vary between 0 and b+1 (+1 because you are at the position after the bth person). If at least a people are in front of you, your position varies between 0 and n-a.
-------------
class Solution:
    def solve(self, n, a, b):
        return min(n-a,b+1)

Anagram Substrings
-------------
Sliding window using Counters. We count the frequency of characters in a window of size l (length of s0). If it equals the frequency of characters in s0, we have a permutation. Then we slide the window by incrementing by the following character frequency, and subtract the frequency of the character no longer included in the window.
-------------
from collections import Counter
class Solution:
    def solve(self, s0, s1):
        l=len(s0)
        if l>len(s1): return 0
        c1=Counter(s0)
        c2=Counter()
        for i in range(l):
            c2[s1[i]]+=1
        ans=0
        for i in range(l, len(s1)):
            if c1==c2: ans+=1
            c2[s1[i-l]]-=1
            if c2[s1[i-l]] == 0: del c2[s1[i-l]]
            c2[s1[i]]+=1
        if c1==c2: ans+=1
        return ans

Maximum Removal Subsequence String
-------------
We build the leftmost greedy subsequence and the rightmost greedy subsequence by iterating by both sides, greedily picking the characters out of our subsequence.

Then, we can either:
1. remove the substring to the left of our rightmost subsequence, 
2. remove the substring to the right of our leftmost subsequence,
3. remove the substring between the leftmost position for the current char and the rightmost position for the next char (which is included in a valid subsequence, as computed previously).

Totally not copied from lasa's solution ;) ;)
-------------
class Solution:
    def solve(self, a, b):
        l=[]
        r=[]
        j=0
        for i,c in enumerate(a):
            if c==b[j]:
                l.append(i)
                j+=1
            if j == len(b): break
        j=len(b)-1
        for i in range(len(a)-1,-1,-1):
            c=a[i]
            if c == b[j]:
                r.append(i)
                j-=1
            if j == -1: break
        r=r[::-1]
        return max(r[0], len(a)-1-l[-1], *[r[i+1]-l[i]-1 for i in range(len(l)-1)])

Linked List Folding
-------------
Cheated solution: fill an array with the nodes. Add the value of corresponding node symmetric to the center. Reverse the Linked List and return the center node.
-------------
# class LLNode:
#     def __init__(self, val, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def solve(self, node):
        a=[x for x in it(node)]
        for i in range((len(a)//2)):
            a[i].val += a[len(a)-i-1].val
        for i in range(1, len(a)):
            a[i].next = a[i-1]
        a[0].next=None
        return a[(len(a)-1)//2]
        
def it(node):
    while node:
        yield node
        node=node.next

Range Update
-------------
We want to avoid doing operations multiple times on the same indices. To do that, we can merge the operations with the following trick: 

Create a new list of events, modifying a running count. For the start of a range, we increment the counter and for the end, we decrement. This way, we only have to touch each number once. 
-------------
class Solution:
    def solve(self, nums, operations):
        events=[]
        for l,r,inc in operations:
            events.append((l,inc))
            events.append((r+1,-inc))
        events.sort()
        inc=0
        ptr=0
        for i in range(len(nums)):
            while ptr<len(events) and events[ptr][0] == i:
                inc+=events[ptr][1]
                ptr+=1
            nums[i]+=inc
        return nums
Invert Tree
-------------
Just do what is told lmao. Don't we just love problems like these?
-------------
# class Tree:
#     def __init__(self, val, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def solve(self, root):
        def dfs(node):
            if not node: return
            l,r=node.left,node.right
            node.left=dfs(r)
            node.right=dfs(l)
            return node
        return dfs(root)

Length of Longest Balanced Subsequence
-------------
We can only take as many closing brackets as we have accumulated opening brackets, and the number of valid parentheses is denoted by the ones we have successfully closed, times two to take into account the opening brackets.
-------------
class Solution:
    def solve(self, s):
        minn=maxx=0            
        for c in s:
            if c == "(": 
                maxx+=1
            elif minn<maxx: 
                minn+=1
        return 2*minn
Circular Longest Increasing Subsequence
-------------
We can use the O(n log n) approach to finding the longest increasing subsequence on an "unwrapped" array made by duplicating the original array. If you don't know the O(n log n) way to finding the LIS, look at the simpler version of this problem - longest increasing subsequence.
-------------
from bisect import bisect_left
class Solution:
    def solve(self, nums):
        a=nums+nums
        ans=0
        for i in range(len(nums)):
            dp=[]
            for j in range(i, len(nums)+i):
                n=a[j]
                k=bisect_left(dp,n)
                if k==len(dp):
                    dp.append(n)
                else:
                    dp[k]=n
            ans=max(ans,len(dp))
        return ans

Valid N Queens
-------------
EDIT: THIS DOESN'T WORK, TEST CASE BAD. Forgot to check backward diagonals.

We can validate each of the three constraints to this problem in one line each.
- To validate that there is exactly one queen per row, we return False if any row contains more (or less) than one queen.
- To validate that there is exactly one queen per column, we repeat the same process as above on the tranposed matrix.
- To validate that there is only one queen per diagonal, we can use a cool trick. For each unique diagonal in a grid, the value of j-i will be constant, because when we iterate over a diagonal, we add one to both j and i. 
Here's an example of grid[i][j] = j-i:
```
i/j 0  1  2
 0  0  1  2
 1 -1  0  1
 2 -2 -1  0
```
So we can create a set of all unique (j-i) values and check that it equals the number of required queens, N (the length of the matrix).

To check for backward diagonals, we can do the same process with (i+j):

```
i/j 0  1  2
 0  0  1  2
 1  1  2  3
 2  2  3  4

-------------
class Solution:
    def solve(self, matrix):
        if any(row.count(1) != 1 for row in matrix): return False
        if any(col.count(1) != 1 for col in zip(*matrix)): return False
        return len(set(j-i for i,row in enumerate(matrix) for j,queen in enumerate(row) if queen)) == len(matrix)

24-Hour Time
-------------
Using Python's date time library, we can parse the string according to the specified format, and print it according to the required format.
-------------
from datetime import datetime
class Solution:
    def solve(self, s):
        return datetime.strptime(s,"%I:%M%p").strftime("%H:%M")

Largest Root to Leaf Sum
-------------
Compute the sum of the subtrees, take the max sum and add the current value.
-------------
class Solution:
    def solve(self, root):
        if not root: return 0
        return root.val + max(self.solve(root.left), self.solve(root.right))

Group Points
-------------
Similar to BFS in some ways:

For every point, we iterate over every point and if its within k distance, we add it to a queue. Then, we repeat the same process for every point in the queue, until the queue is exhausted. At that point, we have a disjoint group.

-------------
from collections import deque

class Solution:
    def solve(self, points, k):
        groups=[]
        seen=set()
        for i in range(len(points)):
            if i in seen: continue
            group=[]
            q=deque([i])
            seen.add(i)
            while q:
                cur=q.popleft()
                group.append(cur)
                px,py = points[cur]
                for j in range(len(points)):
                    if j in seen: continue
                    nx,ny = points[j]
                    if (((px-nx)**2 + (py-ny)**2)**0.5) <= k:
                        seen.add(j)
                        q.append(j)
            groups.append(group)
        return len(groups)

Largest Anagram Group
-------------
We sort the words so anagrams are equal, build a counter and take most frequent.
-------------
from collections import Counter
class Solution:
    def solve(self, words):
        return Counter(map(lambda x: "".join(sorted(x)), words)).most_common(1)[0][1]
Ghost
-------------
Based on Sacha's answer, with a slight modification. We don't have to keep who's turn it is. We can implement something similar to negamax: https://en.wikipedia.org/wiki/Negamax
-------------
_end = '.'
def minmax(tr):
    if _end in tr: 
        return True
    return any(not minmax(t) for t in tr.values())
        
class Solution:
    def solve(self, words):
        trie = dict()
        for word in words:
            current_dict = trie
            for letter in word:
                current_dict = current_dict.setdefault(letter, {})
            current_dict[_end] = True
        return minmax(trie)

Number of Unique Binary Search Trees
-------------
The unique numbers of valid BSTs follow the Catalan sequence.

Why? I don't know. I let the smart people do the math.

https://en.wikipedia.org/wiki/Catalan_number
-------------
from math import factorial as f
class Solution:
    def solve(self, n):
        return f(2*n)//(f(n+1)*f(n)) % (10**9+7)

Symmetric Binary Tree
-------------
We iterate the left child and the right child in reverse order, checking that each corresponding value is equal.
-------------
from itertools import zip_longest as zipl
class Solution:
    def solve(self, root):
        return all(x==y for x,y in zipl(it(root), it(root,False)))

def it(node, left=True):
    if not node: return
    yield from it(node.left if left else node.right, left)
    yield node.val
    yield from it(node.right if left else node.left, left)
Tromino Theory
-------------
Top-down version of lawrence's editorial :)           
-------------
from functools import lru_cache
MOD=10**9 + 7
class Solution:
    def solve(self, n):
        @lru_cache(None)
        def f(n):
            if n <= 2: return n
            return (f(n-1) + f(n-2) + 2*g(n-2)) % MOD
        @lru_cache(None)
        def g(n):
            if n <= 2: return n
            return (f(n-1) + g(n-1)) % MOD
        return f(n)
Double, Reverse, and Swap
-------------
The insight we need to solve this problem efficiently is to realise that each operation is independent. Reversing twice does nothing, even if the string was doubled or characters were swapped, and swapping characters twice does nothing even if the string is reversed or doubled. 

​

Therefore, we only need to check if the number of times we reverse is uneven and the number of times we swap is uneven, and do it once if so.

​

We also count the number of times we have to double with modulos and do it once with an exponential (bitshift could've been used also)

-------------
class Solution:
    def solve(self, n):
        d={"x":"y", "y":"x"}
        s="xxy"
        dbl_count=(n+2)//3
        rev_count=(n+1)//3
        swap_count=(n)//3
        s *= 2 ** dbl_count
        if rev_count % 2 == 1:
            s = s[::-1]
        if swap_count % 2 == 1:
            s = "".join(d[c] for c in s)
        return s

Cell Fusion
-------------
We can simulate the process using a heap, a data structure specialized in accessing the max values of a collections quickly.
-------------
from heapq import heapify, heappop, heappush
class Solution:
    def solve(self, cells):
        cells=[-x for x in cells]
        heapify(cells)
        while len(cells)>1:
            a,b = -heappop(cells), -heappop(cells)
            if a!=b:
                heappush(cells, -((a+b)//3))
        return -cells[0] if cells else -1

Copy Paste
-------------
When n is less or equal to 2, copy-pasting is not worth it.

Otherwise, we have check the parity of n. If the number of operations left is odd, we have to add another character because we need an equal number of copy actions and paste actions. Then, we compute the number of times we double with n//2, the number of copy and paste.
-------------
class Solution:
    def solve(self, n):
        if n<=2: return n
        n-=2
        return (2+(n&1))*(2**(n//2))%(10**9+7)
        

The Maze Runner
-------------
We can count the number of layers the BFS has to explore to reach its target by adding a for loop, exploring only the current nodes in the queue.
-------------
from collections import deque
class Solution:
    def solve(self, matrix):
        if matrix[0][0]: return -1
        w,h=len(matrix[0]),len(matrix)
        s,e=(0,0),(h-1,w-1)
        q=deque([s])
        seen=set()
        ans=1
        while q:
            for _ in range(len(q)):
                pos=q.popleft()
                if pos==e: return ans
                if pos in seen: continue
                seen.add(pos)
                i,j=pos
                for ni,nj in ((i+1,j), (i-1,j), (i,j+1), (i,j-1)):
                    if 0<=ni<h and 0<=nj<w and matrix[ni][nj]==0:
                        q.append((ni,nj))
            ans+=1
        return -1

Ascending Cards
-------------
Same logic as crabmilk with minor optimizations. We apply the logic described in the problem using a double-ended queue, and map the cards to the resulting order. 

- Use a deque to be able to popleft() in constant time.
- Instead of sorting the order, you can make a buffer and assign the card at the correct position.
-------------
from collections import deque
class Solution:
    def solve(self, cards):
        cards.sort()
        idx=[i for i in range(len(cards))]
        order=[]
        q=deque(idx)
        while q:
            order.append(q.popleft())
            if q: q.append(q.popleft())
        ans=[0 for _ in cards]
        for i,card in zip(order,cards):
            ans[i]=card
        return ans

Acronym
-------------
We can build a generator expression that returns the first letter capitalized for each word, and filters "and"s. 
-------------
class Solution:
    def solve(self, s):
        return "".join(w[0].upper() for w in s.split() if w != "and")

Palindromic Tree
-------------
All values in order should equal values iterated in reverse order.
-------------
class Solution:
    def solve(self, root):
        return all(x==y for x,y in zip(in_order(root), reversed_order(root)))
        
def in_order(root):
    if not root: return
    yield from in_order(root.left)
    yield root.val
    yield from in_order(root.right)
    
def reversed_order(root):
    if not root: return
    yield from reversed_order(root.right)
    yield root.val
    yield from reversed_order(root.left)

Friend Groups
-------------
We are looking for connected component in a graph.
One way to do so is to iterate over every vertices and color all the nodes it can reach using dfs, and increment the color counter.
Color is just a unique identifier that identify our connected components.
-------------
class Solution:
    def solve(self, friends):
        colors={}
        def dfs(i,color):
            if i in colors:
                return
            colors[i]=color
            for f in friends[i]:
                dfs(f,color)
        color=0
        for i in range(len(friends)):
            if i not in colors:
                dfs(i, color)
                color+=1
        return color

A Flight of Stairs
-------------
Classic DP problem, identical to fibonacci. https://www.geeksforgeeks.org/count-ways-reach-nth-stair/
-------------
MOD=(10**9)+7
class Solution:
    def solve(self, n):
        dp=[0 for _ in range(n+2)]
        dp[1]=1
        for i in range(2,n+2):
            dp[i]=dp[i-1]+dp[i-2]
        return dp[-1]%MOD
Next Integer Permutation
-------------
my implementation sucks, but the logic is the following:

You iterate on the number from the right, finding the first digit that has a bigger digit than itself to its right.

Then, you find the smallest digit to its right that is bigger than it, you swap them and sort everything to its right.
-------------
class Solution:
    def solve(self, num):
        mx=0
        s=str(num)
        idx=-1
        ref=-1
        for i in range(len(s)-1,-1,-1):
            n=int(s[i])
            if n < mx:
                idx=i
                ref=n
                break
            elif n > mx: mx = n
        mn=1e9
        nidx=-1
        for i in range(idx+1, len(s)):
            n=int(s[i])
            if n > ref and n < mn: 
                mn = n
                nidx = i
        s = [c for c in s]
        s[idx],s[nidx] = s[nidx], s[idx]
        s = s[:idx+1] + sorted(s[idx+1:])
        ans= int("".join(s))
        if ans == num: return int("".join(sorted(s,key=int)))
        return ans
            

Poly Knapsack
-------------
This is the same thing as 0/1 knapsacks but when you pick a knapsack, you don't immediately skip to the next one.

For summary, we recursively pick (or not) each knapsack. We memoize using the current weight and the remaining capacity as key.
-------------
from functools import lru_cache
class Solution:
    def solve(self, weights, values, capacity):
        @lru_cache(None)
        def dp(i,k):
            if i==len(weights): return 0
            ans=dp(i+1,k)
            if k>=weights[i]:
                ans=max(ans,dp(i,k-weights[i])+values[i])
            return ans
        return dp(0,capacity)

Sum of the Digits
-------------
We take the last digit by computing modulo ten, and then we shift the number to the right by dividing by ten. The divmod function can do both of those operation at the same time.
-------------
class Solution:
    def solve(self, num):
        a=0
        while num:
            num,m=divmod(num,10)
            a+=m
        return a

String Isomorphism
-------------
Since each unique character in S should equal one unique character in T and vice versa, we can check that the number of unique pairs of corresponding letters equal the number of unique characters in S and T.
-------------
class Solution:
    def solve(self, s, t):
        return len(set(zip(s,t))) == len(set(s)) == len(set(t))
Substringify
-------------
We try every possible offset for the substring t, and then we compute the cost of making it equal to the substring of s by checking the number of unequal characters.
-------------
class Solution:
    def solve(self, s, t):
        ans=len(t)
        for i in range(len(s)-len(t)+1):
            a=len(t)
            for j in range(len(t)):
                if t[j] == s[i+j]: a-=1
            ans=min(ans, a)
        return ans
Reverse Graph
-------------
Initially, we have a list that goes like this:
i1 -> [x1,x2,x3]
i2 -> [x4,x5,x6]
...
We need to flip it so that the x's point to their indexes.
-------------
class Solution:
    def solve(self, graph):
        ans=[[] for _ in graph]
        for i,l in enumerate(graph):
            for x in l:
                ans[x].append(i)
        return ans
            

Subtree
-------------
Each time the root and the target match, we check if they all share common children from that point on, otherwise we keep exploring the root.
-------------
# class Tree:
#     def __init__(self, val, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def solve(self, root, target):
        if not root or not target: return not root and not target
        elif root.val == target.val:
            if self.solve(root.left,target.left) and self.solve(root.right, target.right): return True
        return self.solve(root.left,target) or self.solve(root.right,target)

Largest K-Divisible Subsequence
-------------
The constraints k is less than 10 gives us a hint about the state we need to track in our DP. In fact, we only need to know the current modulo in regards to k to know if our answer is valid, so when we pick a number, we update the (sum % k) and when we skip one number we leave it intact.

A neat trick is to return float('-inf') when an answer is invalid, as all the sums will be reduced to nothing.

Complexity is O(n*k), but since we know k is smaller than 10, this is practically linear.
-------------
from functools import lru_cache
class Solution:
    def solve(self, nums, k):
        @lru_cache(None)
        def dp(i,sum_mod_k):
            if i == len(nums):
                if sum_mod_k == 0: 
                    return 0
                else:
                    return float('-inf')
            new_mod_k = (sum_mod_k + nums[i]) % k
            return max(dp(i+1, sum_mod_k), dp(i+1, new_mod_k)+nums[i])
        return dp(0, 0)
            

Maximum Consecutive Difference
-------------
Why is this is hard? Lawrence plz fix.                   
-------------
class Solution:
    def solve(self, nums):
        nums.sort()
        ans=0
        for i in range(len(nums)-1):
            ans=max(ans, nums[i+1]-nums[i])
        return ans

Minimum Cost Sort
-------------
To compute the cost, compute the sum of the difference of corresponding numbers in the original list and the sorted ones. Take the minimum.
-------------
class Solution:
    def solve(self, nums):
        return min(
            sum(abs(x-y) for x,y in zip(nums,sorted(nums))),
            sum(abs(x-y) for x,y in zip(nums,sorted(nums, reverse=True)))
        )

Sum of First N Odd Integers
-------------
The sum of the first n odd numbers is n^2. We can demonstrate this by finding the average value of this arithmetic series and multiplying it n times. The average value times the number of values will give the sum.

The first element of the series is 1, and the nth element is 2(n-1)+1. 
So, the average value will be:
```
(1+2(n-1)+1)/2
(1+2n-2+1)/2
2n/2
n
```
We multiply it by n (the number  of values in the series) and we get n^2.
-------------
class Solution:
    def solve(self, n):
        return n*n
Robinhood
-------------
We can use cycle to endlessly alternate between the two interest rates.
-------------
from itertools import cycle
class Solution:
    def solve(self, n, e, o, t):
        ans=0
        for i in cycle((e,o)):
            if n>=t: return ans
            n*=1+(i/100)
            ans+=1

Zigzag String
-------------
We have an array containing each row of our answer, but we need a way to keep track of which row to add our character while iterating over the string.

We can build our own zigzag iterator by chaining an ascending range iterator (range(k)) and a descending range iterator (range(k-2, 0,- 1) and make it repeat indefinitely with cycle().

While iterating over characters in the string, we call next(row_itr) to get the next value in the iterator. We add the character to that row, and add  a space to the other rows for padding.
-------------
from itertools import chain, cycle
class Solution:
    def solve(self, s, k):
        rows=["" for _ in range(k)]
        row_itr=cycle(chain(range(k), range(k-2, 0, -1)))
        for c in s:
            row_idx=next(row_itr)
            for j in range(k):
                if j == row_idx:
                    rows[j]+=c
                else:
                    rows[j]+=" "
        return "\n".join(rows)

Rod Cutting
-------------
Memoized solution: we try every possible cut on the rod, and maximize the resulting price.
-------------
from functools import lru_cache
class Solution:
    def solve(self, prices, n):
        @lru_cache(None)
        def dp(rem):
            if rem==0: return 0
            return max(dp(rem-i-1)+prices[i] for i in range(rem))
        return dp(n)

Sum of Three Numbers Sequel
-------------
O(n^2) solution.

We sort the number, so we know what to do when we are smaller or bigger than the target.

When we are smaller, we know we have to increment one of the numbers, otherwise we need to reduce one of our numbers.

That is the logic behind this algo: Select one number, and then use two pointers for the next two numbers: the smallest value and the greatest value after i. Compute the sum, and if we are greater than target, reduce greatest value and if smaller, increment smaller number.
-------------
class Solution:
    def solve(self, nums, target):
        nums.sort()
        ans=1e9
        for i in range(len(nums)-2):
            j=i+1
            k=len(nums)-1
            while j<k:
                sm=nums[i]+nums[j]+nums[k]
                if abs(sm-target) < abs(ans-target):
                    ans=sm
                if sm==target: return sm
                elif sm<target:
                    j+=1
                else:
                    k-=1
        return ans

CCCXXVV
-------------
Hack-ish solution, but since there's a small number of numbers where the prefix is smaller, you can just enumerate them. 

Also, dictionaries are not ordered, so if single-letter roman numbers are iterated through first, this wouldn't work. 
-------------
d={
    'CM': 900,
    'XL': 40,
    'IX': 9,
    'IV': 4,
    'M': 1000,
    'D': 500,
    'C': 100,
    'L': 50,
    'X': 10,
    'V': 5,
    'I': 1
}
class Solution:
    def solve(self, numeral):
        a=0
        for k,v in d.items():
            a+=numeral.count(k)*v
            numeral=numeral.replace(k,"")
        return a

The Meeting Place
-------------
For each twos (2) in the grid, we create a cost matrix using BFS.

Then we iterate over each index, calculating the sum of the cost matrix of every two and taking the min from all the sums.
-------------
class Solution:
    def solve(self, matrix):
        twos={}
        costs={}
        for i,r in enumerate(matrix):
            for j,v in enumerate(r):
                if v==2:
                    twos[(i,j)]=[(i,j,0)]
                    costs[(i,j)]=[[1e9 for _ in matrix[0]] for _ in matrix]
        for k,q in twos.items():
            seen=set()
            while q:
                i,j,cost=q.pop(0)
                if (i,j) in seen: continue
                seen.add((i,j))
                costs[k][i][j] = cost
                for di, dj in ((1,0),(-1,0), (0,1),(0,-1)):
                    ni,nj=i+di,j+dj
                    if ni>=0 and nj>=0 and ni<len(matrix) and nj<len(matrix[0]) and matrix[ni][nj]!=1:
                        q.append((ni,nj,cost+1))
        ans=1e9
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                cur_cost=0
                for arr in costs.values():
                    cur_cost+=arr[i][j]
                ans=min(ans,cur_cost)
        return ans

Swapping Socks
-------------
One important note about this problem is that pairs can be unordered, so (1,0) and (0,1) are both valid pairs.

We iterate over the current pairs of the array. We look at the first sock in the pair, and compute the expected second pair by flipping the last bit, so the even pair will give the odd pair and vice-versa.

If the pairs don't match, find the index of the expected pair and greedily swap.
-------------
class Solution:
    def solve(self, row):
        idx={v:i for i,v in enumerate(row)}
        ans=0
        for i in range(0,len(row), 2):
            first=row[i]
            second = first^1
            if row[i+1]!=second:
                j=idx[second]
                row[i+1],row[j]=row[j],row[i+1]
                idx[row[j]]=j
                ans+=1
        return ans
2048
-------------
1. We rotate every direction to left to simplify procedure;
2. We eliminate 0 values to simply tracking neighbors;
3. We merge identical neighbors;
4. We pad with zeroes;
5. We restore original orientation.

(I called fn three times to restore 90 degrees rotation).
-------------
class Solution:
    def solve(self, board, direction):
        fn=mapping[direction]
        return fn(fn(fn(fill(merge(fltr(fn(board)))))))
        
mapping = {
    "left": lambda lst: lst,
    "right": lambda lst: [l[::-1] for l in lst],
    "down": lambda lst: list(zip(*lst[::-1])),
    "up": lambda lst: list(zip(*lst))
}

def fltr(lst):
    return [[v for v in l if v != 0] for l in lst]

def merge(lst):
    for l in lst:
        i=0
        while i<len(l)-1:
            if l[i]==l[i+1]:
                l[i]*=2
                l.pop(i+1)
            i+=1
    return lst

def fill(lst):
    for i in range(len(lst)):
        while len(lst[i]) != 4: 
            lst[i].append(0)
    return lst
Fractional Knapsack
-------------
We can greedily take knapsacks with the largest ratio of value per weight unit. When we reach a knapsack we can't take completely, we take the largest fraction possible.
-------------
class Solution:
    def solve(self, weights, values, capacity):
        a=[(val/wei, wei, val) for wei, val in zip(weights,values)]
        a.sort(reverse=True)
        i=0
        ans=0
        while i<len(a) and capacity>0:
            ratio,weight,value = a[i]
            if weight<= capacity:
                capacity-=weight
                ans+=value
            else:
                ans+=(capacity/weight)*value
                capacity=0
            i+=1
        return int(ans)

Make a Palindrome by Inserting Characters
-------------
For each non-matching character, we can either add an imaginary character to the left of the string to match the right one (in that case, we will only move j to the left) or add an imaginary character to the right of the string to match the left one (in that case, we will move i to the right). Since palindromes contain smaller palindromes, we can do this recursively. Example:

"radar" -> "ada" -> "d".

Here a letter is missing, so we just shift one pointer, which is equivalent to adding the correct character:

"rada"  -> "ada" -> "d".
"adar" -> "ada" -> "d".
-------------
from functools import lru_cache
class Solution:
    def solve(self, s):
        @lru_cache(None)
        def dp(i,j):
            if i>=j: return 0
            if s[i]==s[j]:
                return dp(i+1,j-1)
            else:
                return min(dp(i+1,j), dp(i,j-1))+1
        return dp(0,len(s)-1)
First Missing Positive Sequel
-------------
The sum of the arithmetic series 1+2+3+...+n is equal to 
n * (n+1) / 2. The proof of this is that the average value is the series is (n+1)/2 and there are n elements.

So if we take the expected sum of all elements from 1 to n and subtract the actual sum, it will return the missing number from the series.
-------------
class Solution:
    def solve(self, arr):
        n=len(arr)+1
        return n*(n+1)//2 - sum(arr)

Low Score
-------------
Basically Dijkstra's algorithm, but instead of using total distance as the min-heap key, we use the custom key described in the problem, the number of edges times the maximum weight.
-------------
from collections import defaultdict,deque
from heapq import heappush, heappop
class Solution:
    def solve(self, edges):
        adj = defaultdict(list)
        nodes=set()
        for u,v,w in edges:
            adj[u].append((v,w))
            adj[v].append((u,w))
            nodes.add(u)
            nodes.add(v)
        hp=[(0,0,0,0)]
        target = max(nodes)
        seen=set()
        while hp:
            key,edgecount,maxweight,cur = heappop(hp)
            if cur == target: 
                return key
            if cur in seen:
                continue
            seen.add(cur)
            for nei,wei in adj[cur]:
                next_edgecount = edgecount+1
                next_maxweight = max(maxweight, wei)
                next_key = next_edgecount*next_maxweight
                heappush(hp, (next_key, next_edgecount,next_maxweight, nei))
        return -1
        

Detect Voter Fraud
-------------
If the length of the set made out of unique voter ids is the same as the length of the votes, we know each vote has a unique voter.

P.S. use set comprehensions like alex, to avoid converting list to set.
-------------
class Solution:
    def solve(self, votes):
        return len(set([x[1] for x in votes]))!=len(votes)

Overchoice
-------------
Sexy one-liner: we replace all "[" with "]", then we can split over all "]". Then, for all strings in the result, if there is the character "|", we split it, otherwise we return the string in a list [s]. Then the product function will generate all products like the problem describes. We join and sort the result.
-------------
from itertools import product
class Solution:
    def solve(self, s):
        return sorted(["".join(a) for a in product(*[s.split("|") if "|" in s else [s] for s in filter(None,s.replace("[","]").split("]"))])])
Vanity Phone Numbers
-------------
Python's itertools offer the product function, that returns the cartesian product of N collections. 

The cartesian product is all the combinations of one element from each container, which is exactly what we want.
See: https://en.wikipedia.org/wiki/Cartesian_product

So we map every digit to its possible characters and let product generate all the possibilities.
-------------
from itertools import product
dct={
    "2":"abc",
    "3":"def",
    "4":"ghi",
    "5":"jkl",
    "6":"mno",
    "7":"pqrs",
    "8":"tuv",
    "9": "wxyz",
}
class Solution:
    def solve(self, digits):
        return ["".join(combination) for combination in product(*[dct[d] for d in digits])]
        

Equalize List
-------------
solution isn't valid anymore - look at other editorial.
-------------
from collections import defaultdict
class Solution: 
    def solve(self, nums, costs):
        agglcost=defaultdict(int)
        for i,n in enumerate(nums):
            agglcost[n]+=costs[i]
        mn = min(nums)
        mx = max(nums)
        cost=0
        while mn != mx:
            costmin=agglcost[mn]
            costmax=agglcost[mx]
            if costmin < costmax:
                agglcost[mn+1] += agglcost[mn]
                mn+=1
                cost+=costmin
            else:
                agglcost[mx-1] += agglcost[mx]
                mx-=1
                cost+=costmax
        return cost
            
                

Course Scheduling
-------------
This problem is about checking if topological sorting is possible, which equates to checking if the graph is a DAG (Directed Acyclic Graph).

To check whether our graph has cycles, we can simply do a depth-first search on every node and check if we ever return on a visited value. 

When we completed the depth-first search on a node, we never need to check it again, hence the checked array.

Relevant reading: https://en.wikipedia.org/wiki/Topological_sorting
-------------
class Solution:
    def solve(self, matrix):
        visited=[False for _ in matrix]
        checked=[False for _ in matrix]
        def dfs(i):
            if visited[i]: return False
            if checked[i]: return True
            visited[i]=True
            for j in matrix[i]:
                if not dfs(j):
                    return False
            visited[i]=False
            checked[i]=True
            return True
        for i in range(len(matrix)):
            if not dfs(i):
                return False
        return True
Add Linked Lists
-------------
We can use a generator to easily iterate over the linked lists, and zip_longest to match corresponding values. If one linked list is longer than the other, zip_longest will use the fillvalue (0 in this case, which won't affect the sum).
-------------
from itertools import zip_longest
class Solution:
    def solve(self, l0, l1):
        head=pre=LLNode(0)
        carry = 0
        for x,y in zip_longest(it(l0), it(l1), fillvalue=0):
            carry, res = divmod(x+y+carry, 10)
            pre.next = LLNode(res)
            pre=pre.next
        if carry: pre.next = LLNode(carry)
        return head.next
        
def it(node):
    while node:
        yield node.val
        node=node.next
Fair Pay
-------------
The key to this problem is to remember to iterate left-to-right and right-to-left. To illustrate the importance of this, let's take this test case:
[3,2,1,2,3]
If we only iterate left-to-right, we will never consider the strictly increasing sequence 3-2-1.
Probably possible in constant space with a stricly increasing counter, but that will be left as an exercice to the reader :).
-------------
class Solution:
    def solve(self, ratings):
        pay=[1 for _ in ratings]
        for i in range(1, len(ratings)):
            if ratings[i] > ratings[i-1]:
                pay[i] = pay[i-1]+1
        for i in range(len(ratings)-2,-1,-1):
            if ratings[i] > ratings[i+1]:
                pay[i] = max(pay[i], pay[i+1]+1)
        return sum(pay)
Mad Max
-------------
The trick to doing this in O(n) is to use a queue of maxes. When we encounter a new value, we remove all those lower than it and add it to the queue, so that the elements in the queue are always sorted decreasingly, and the front of the queue is always the current max.

More visuals here: https://www.geeksforgeeks.org/sliding-window-maximum-maximum-of-all-subarrays-of-size-k/
-------------
from collections import deque
class Solution:
    def solve(self, nums, k):
        q=deque()
        ans=[]
        for i,n in enumerate(nums):
            if q and q[0]<=i-k: q.popleft()
            while q and n>=nums[q[-1]]:
                q.pop()
            q.append(i)
            if i>=k-1: ans.append(nums[q[0]])
        return ans

K Unique String
-------------
We find the unique numbers and their frequencies using a Counter. If we have more than k distinct numbers, we need to change the least frequent numbers to obtain the minimum number of changes.

We can obtain the least frequent values from a counter by reversing the result of most_common(), or just removing the value from the end.
-------------
from collections import Counter
class Solution:
    def solve(self, s, k):
        counter=Counter(s)
        L = len(counter)
        if L<=k: return 0
        return sum(cnt for _,cnt in counter.most_common()[-(L-k):])

Factorial Sum
-------------
For each factorial f(i), f(i) is greater than the sum of f(1)+f(2)+...+f(i-1). That is because we multiply the greatest value of the sequence by i, one times more than the number of elements in the previous sequence. 

Therefore, we know if f(i) is smaller than n, we have to use it in our sum of factorials, because if we don't we will never get a value big enough to reach n. 

So we iterate from an arbitrary upper bound (20 in this case) and descend, removing each value big enough to fit in n, and check if we reach 0.
-------------
from math import factorial as f
class Solution:
    def solve(self, n):
        for i in range(20,0,-1):
            fact=f(i)
            if fact<=n:
                n-=fact
        return n==0

Rocketship Rescue
-------------
Each iteration, we put the fattest dude on the ship. Then we check the lightest. If he can't go on the ship, then we know that no other person can because they're all fatter. 
-------------
class Solution:
    def solve(self, weights, limit):
        weights.sort()
        cnt=0
        while weights:
            x=weights.pop()
            if weights and weights[0]<=limit-x:
                weights.pop(0)
            cnt+=1
        return cnt
                

Parse Boolean Expression
-------------
Why implement a boolean expression evaluator, if Python can already do it for you?
-------------
class Solution:
    def solve(self, s):
        true=True
        false=False
        return eval(s)

Kth Smallest Element
-------------
Using a heap, we can find the desired value in O(k log n).
-------------
from heapq import heapify, heappop
class Solution:
    def solve(self, nums, k):
        heapify(nums)
        for i in range(k):
            heappop(nums)
        return heappop(nums)
        # Write your code here

Dictionary Nomad
-------------
The challenge in this problem is to efficiently build the graph representing the valid transitions between words. One way is to group words by strongly connected components, where every word in the same bucket share all letters except one, and then we can retrieve the neighbors of a word by retrieving all the strongly connected components they belong to. 

When we have a way to get neighbors of a word, we can apply the classic BFS approach to find the shortest path in a non-weighted graph.
-------------
from collections import defaultdict,deque
class Solution:
    def solve(self, dictionary, start, end):
        components=defaultdict(list)
        neighbors=defaultdict(set)
        l = len(dictionary[0])
        for omit in range(l):
            for w in dictionary:
                key=(omit,w[:omit],w[omit+1:])
                components[key].append(w)
        def get_neighbors(word):
            for omit in range(len(word)):
                key=(omit,word[:omit],word[omit+1:])
                if key in seen_components: continue
                for nxt in components[key]:
                    if nxt not in seen and nxt != word:
                        yield nxt
                seen_components.add(key)
        q=deque([start])
        seen=set([start])
        seen_components=set()
        ans=0
        while q:
            ans+=1
            for _ in range(len(q)):
                node=q.popleft()
                if node == end: return ans
                for nxt in get_neighbors(node):
                    seen.add(nxt)
                    q.append(nxt)
        return -1
Longest Common Prefix
-------------
We can compare characters at the same position by zipping them together, and to check if they're all equal we can check that the set of characters is length 1.
-------------
class Solution:
    def solve(self, words):
        ans=""
        for x in zip(*words):
            if len(set(x))==1:
                ans+=x[0]
            else: break
        return ans

Pattern Matching
-------------
We recursively iterate over each letter in the pattern. If it doesn't exist in the mappings, we try every possible prefix of the string as a mapping.

Otherwise, we compare the mapping to the string, seeing if it matches the start. 
-------------
class Solution:
    def solve(self, s, p):
        uniq=set(p)
        def parse(s,p, mappings=dict()):
            if not s and not p and len(mappings) == len(uniq): return True
            if not s or not p: return False
            c=p[0]
            if c not in mappings:
                for i in range(len(s)):
                    mappings[c] = s[:i+1]
                    if parse(s[i+1:],p[1:],mappings): return True
                    del mappings[c]
                return False
            else:
                mapp = mappings[c]
                if len(mapp)>len(s): return False
                for i in range(len(mapp)):
                    if mapp[i] != s[i]: return False
                return parse(s[len(mapp)+1:], p[1:], mappings)
        return parse(s,p)
List Equality with Increments
-------------
The strategy used here is for for each iteration, we take the max and the min, and increment until the min is equal to the max. For example:
```
[1,2,3,4]
```
We have 4 as max, and 1 as min. We increment every number by (4-1) except 4:
```
[4,5,6,4]
```
We now have two equal numbers, and our problem is reduced. We repeat the process with max (6) and min(4):
```
[6,7,6,6]
```
And again with 7 and 6:
```
[7,7,7,7]
```
For each step, we can notice that __the difference between any number and the min never changes__, until we select it and equalize with the number, and then the cost will be xi-min.
In our example, the difference between 3 and 1 is 2, and when we increment the min, the difference between the same numbers (6 and 4) is still 2.
-------------
class Solution:
    def solve(self, nums):
        mn=min(nums)
        return sum(x-mn for x in nums)
Embolden
-------------
We can use regex to find all overlapping matches of each pattern: https://stackoverflow.com/questions/4664850/how-to-find-all-occurrences-of-a-substring

We store the length of the pattern, and the position at which it has been seen in a list. Then when iterating, we keep a decrementing counter, and when it reaches zero, we are no longer in a match.
-------------
import re
class Solution:
    def solve(self, text, patterns):
        patterns=set(patterns)
        mark=[0 for _ in text]
        for p in patterns:
            l=len(p)
            for m in re.finditer(f"(?={p})",text):
                i = m.start()
                mark[i] = max(mark[i], l)
        ans=[]
        cnt=0
        for i,c in enumerate(text):
            new_cnt=max(mark[i],cnt-1)
            if not cnt and new_cnt: ans.append("<b>")
            elif cnt and not new_cnt: ans.append("</b>")
            ans.append(c)
            cnt=new_cnt
        if cnt: ans.append("</b>")
        return "".join(ans)
Longest Alternating Subsequence
-------------
We can keep two dp arrays - one where the last number is increasing and one where the last number is decreasing. 
-------------
class Solution:
    def solve(self, nums):
        if not nums: return 0
        inc=[1 for _ in nums]
        dec=[1 for _ in nums]
        for i in range(len(nums)):
            for j in range(i):
                if nums[i] > nums[j]:
                    inc[i] = max(inc[i], dec[j]+1)
                elif nums[i] < nums[j]:
                    dec[i] = max(dec[i], inc[j]+1)
        return max(max(inc),max(dec))
Birthday Party
-------------
Dequeue's rotate function helps us emulate skipping over children.
-------------
from collections import deque
class Solution:
    def solve(self, n, k):
        q=deque(range(n))
        while len(q)>1:
            q.rotate(-k)
            q.popleft()
        return q[0]
Skip Tasks to Minimize Work
-------------
Memoized solution: we can try skipping one value or not skipping. We can also skip the first value, so we try starting for both index 0 and 1.
-------------
from functools import lru_cache
class Solution:
    def solve(self, nums):
        @lru_cache(None)
        def dp(i):
            if i >= len(nums): return 0
            return min(dp(i+1), dp(i+2))+nums[i]
        return min(dp(0), dp(1))

A* Student
-------------
We process the jobs in sorted order according to deadlines, to maximize the time we have to complete a set of deadlines.
Then, we iterate recursively on the jobs. For each job we have two options: either to take it or not to take it. 
If we don't take it, the days don't go forward, but if we do, we add the duration of the job to the current day.

We return the maximum of credits we reach from the subproblems.
-------------
from functools import lru_cache
class Solution:
    def solve(self, deadlines, credits, durations):
        jobs=sorted(zip(deadlines,durations,credits))
        @lru_cache(None)
        def dp(i=0, day=0):
            if i >= len(jobs): return 0
            ans=dp(i+1,day)
            deadline,duration,credit=jobs[i]
            if day+duration-1 <= deadline:
                ans=max(ans, dp(i+1, day+duration)+credit)
            return ans
        return dp()

Unique Ab Strings
-------------
Each a has two possibilities: a or b. So each time we encounter an "a", we double the number of possibilities.

We can express this with an base 2 exponential.
-------------
class Solution:
    def solve(self, s):
        return 2**s.count("a")%(10**9+7)

Popularity
-------------
The number of paths going through (a,b) is the number of children nodes counting from b (left) times the total number of nodes minus left.
-------------
from collections import defaultdict
class Solution:
    def solve(self, edges):
        if not edges: return []
        adj_list=defaultdict(list)
        parent=defaultdict(int)
        nodes=set()
        for s,e in edges:
            adj_list[s].append(e)
            parent[e]=s
            nodes.add(s)
            nodes.add(e)
        counts=defaultdict(int)
        total=len(nodes)
        def dfs(node):
            counts[node] = sum(dfs(nei) for nei in adj_list[node])
            return counts[node]+1
        root=edges[0][0]
        while root in parent: root=parent[root]
        dfs(root)
        ans=[]
        for s,e in edges:
            left=counts[e]+1
            right=total-left
            ans.append(left*right)
        return ans
All Sublists Sum
-------------
Any contiguous subarray can be defined by their left bound and their right bound: i,j.

For a position k to be contained within a subarray, i <= k <= j.
The number of possibilities for i that satisfy this condition are k+1 and the number of possibilities for j is N-k.

We can get the number of combinaison by doing the product of possibilities, which results in the number of occurences of the number.
-------------
class Solution:
    def solve(self, nums):
        N=len(nums)
        ans=0
        for i in range(len(nums)):
            n=nums[i]
            ans += (i+1) * (N-i) * n
        return ans%1000000007

Factory Trail
-------------
Fancy math explained here: https://www.geeksforgeeks.org/count-trailing-zeroes-factorial-number/
-------------
class Solution:
    def solve(self, n):
        count = 0
        i=5
        while (n/i>=1): 
            count += int(n/i) 
            i *= 5
        return int(count) 
Foo Bar Qaz Qux
-------------
Three cases:
If there is only one unique color: return the length of the string.

Now it gets funky. If the frequency are all even or all odd, the answer will be two. Here's my best explanation as to why. At each iteration, we remove one from the frequency of two colors, and add one to the frequency of the last color. Here's an illustration, where R and G are combined.

R G B
4 4 4
3 3 5
If we remove one from an even number, it will give an odd number. The same holds when we add one to an even number. So if all frequencies are even on one iteration, they will all be odd on the next, and then even, etc. Following this line of logic, the frequency of each color will eventually be (1,1,1):

R G B
4 4 4
3 3 5
2 2 6
1 1 7
2 0 6
1 1 5
2 0 4
1 1 3
2 0 2
1 1 1
And when that happens, we are fucked. Because when we combine two of those colors, we will be left with two identical colors.

Here's what happens if they are not all even or odd:

R G B
3 4 4
2 3 5
1 2 6
0 1 7
1 0 6
0 1 5
1 0 4
0 1 3
1 0 2
0 1 1
In the final state, one or two numbers will be even, and the rest one will be odd. If two ones are left, we can make our last one, otherwise we already reached our end state.


-------------
from collections import Counter
class Solution:
    def solve(self, quxes):
        cnt=Counter(quxes)
        if len(cnt)==1: return len(quxes)
        odds = 0
        for freq in cnt.values():
            odds += freq & 1
        if odds == 3 or odds == 0: return 2
        return 1
        
# 2 2 1
# 1 1 2
Binary Tree Longest Consecutive Path
-------------
My solution is kinda fucked, but I transformed the tree into a undirected graph so it was possible to explore nodes in all directions.
-------------
from collections import defaultdict
class Solution:
    def solve(self, root):
        adj_list=defaultdict(list)
        def dfs(node):
            for c in (node.left,node.right):
                if not c: continue
                adj_list[node].append(c)
                adj_list[c].append(node)
                dfs(c)
        dfs(root)
        seen=set()
        def longest(node,diff=None):
            seen.add(node)
            l=0
            for nei in adj_list[node]:
                if nei in seen: continue
                if diff is None:
                    if abs(node.val-nei.val)==1:
                        l=max(l,1+longest(nei,nei.val-node.val))
                elif nei.val-node.val == diff:
                    l=max(l,1+longest(nei,nei.val-node.val))
            seen.remove(node)
            return l
        ans=0
        for node in adj_list:
            ans=max(ans, longest(node))
        return ans+1
Direct Closure
-------------
BFS solution: iterate over each node (indexes), and mark all the neighbors it can reach.
-------------
class Solution:
    def solve(self, graph):
        ans=[[0 for _ in graph] for _ in graph]
        for i in range(len(graph)):
            q=[i]
            while q:
                node=q.pop(0)
                if ans[i][node]: continue
                ans[i][node]=1
                neighbors=graph[node]
                for n in neighbors:
                    q.append(n)
        return ans

Add Binary Numbers
-------------
You can parse the binary string with the int constructor. The second parameter specifies the base. Then we reconvert the result to binary, and remove the prefix "0b".
-------------
class Solution:
    def solve(self, a, b):
        return bin(int(a,2)+int(b,2))[2:]

Subsequence Widths
-------------
We can sort, since subsequences don't care about contiguity.

Then we iterate over each number - we subtract our answers by the number of times the current number is the minimum of a subsequence and add it the number of times it is the maximum of a subsequence.

To get the number of possible subsequence with n as the min or max, we count the number of number to its right (or left for max). For each number, there is 2 possible states - either we take it or not. So each number will double the number of possibilities, hence the powers_of_two[r].
-------------
MOD = (10 ** 9) + 7
class Solution:
    def solve(self, nums):
        if len(nums) < 2: return 0
        powers_of_two = [0 for _ in nums]
        powers_of_two[0] = 1
        for i in range(1,len(powers_of_two)):
            powers_of_two[i] = powers_of_two[i-1]*2 % MOD
        ans=0
        nums.sort()
        for i,n in enumerate(nums):
            r=i
            l=len(nums)-i-1
            ans+=n * powers_of_two[r]
            ans-=n * powers_of_two[l]
        return ans % MOD
Elephant Tree
-------------
HaVe dFs(nOdE) rEtUrNs tHe sUm oF ThE SuBtReE Of eAcH NoDe, PlUs sEtS NoDe.vAl eQuAl tO ThAt sUbTrEe sUm. (lEt's cAlL ThIs tHe cOnTrAcT Of dFs.)

NoW LeT'S Do a pOsToRdEr tRaVeRsAl. FoR EaCh nOdE ViSiTeD, wE'Ll vIsIt tHe sUbTrEeS FiRsT, sO ThAt nOdE.LeFt iS ThE SuM Of tHe lEfT SuBtReE, aNd nOdE.RiGhT Is tHe sUm oF ThE RiGhT SuBtReE. fRoM ThErE, iT Is eAsY To fUlFiLl tHe sTaTeD CoNtRaCt oF DfS.
-------------
class Solution:
    def solve(self, root):
        def dfs(node):
            if not node: return 0
            l=dfs(node.left)
            r=dfs(node.right)
            node.val += l+r
            return node.val
        dfs(root)
        return root

Number of Sublists With Sum of Target
-------------
We keep a running sum from all elements from 0 to i, and we increment the number of times we have seen this sum.

Each time we have a sum at an index, you can calculate the difference of the current sum with the target value.

If the running sum was equal to that difference at some point, you can remove that previous running sum from the current to make a sublist. 


-------------
from collections import defaultdict
class Solution:
    def solve(self, nums, target):
        seen=defaultdict(int)
        seen[0]=1
        s=0
        ans=0
        for i in range(len(nums)):
            s+=nums[i]
            comp=s-target
            if comp in seen:
                ans+=seen[comp]
            seen[s]+=1
        return ans

Leaf Equivalent Trees
-------------
We can use a generator to iterate through the leaves of each tree.
Then we can zip all corresponding leaves and check their equality.
-------------
from itertools import zip_longest as zipl
class Solution:
    def solve(self, root0, root1):
        return all(x==y for x,y in zipl(leaves(root0), leaves(root1)))
def leaves(node):
    if not node.left and not node.right: yield node.val
    if node.left: yield from leaves(node.left)
    if node.right: yield from leaves(node.right)

Minimum Digit Delete
-------------
Algorithm based on Levenshtein distance, where the cost of deleting a character is the value of the digit deleted.

https://en.wikipedia.org/wiki/Levenshtein_distance
-------------
class Solution:
    def solve(self, s0, s1):
        dp=[[0 for _ in range(len(s1)+1)] for _ in range(len(s0)+1)]
        for i in range(1,len(s0)+1):
            dp[i][0]=dp[i-1][0]+int(s0[i-1])
        for j in range(1,len(s1)+1):
            dp[0][j]=dp[0][j-1]+int(s1[j-1])
        for i in range(1,len(s0)+1):
            for j in range(1,len(s1)+1):
                dp[i][j] = min(
                    dp[i-1][j]+int(s0[i-1]),
                    dp[i][j-1]+int(s1[j-1])
                    )
                if s0[i-1]==s1[j-1]:
                    dp[i][j] = min(dp[i][j], dp[i-1][j-1])
        return dp[-1][-1]
Color Map
-------------
We find groups of different colors using BFS, and storing the count of groups of a certain color in a dictionary.

Then, we want to keep the most frequent color, and change the rest of the groups that aren't of that color.
-------------
from collections import defaultdict,deque
class Solution:
    def solve(self, matrix):
        if not matrix: return 0
        def get_neighbors(i,j):
            for di,dj in [(-1,0), (1,0), (0,1), (0,-1)]:
                ni,nj = i+di, j+dj
                if ni>=0 and nj>=0 and ni<len(matrix) and nj<len(matrix[0]):
                    yield (ni,nj)
                    
        colors=defaultdict(int)
        seen=set()
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if (i,j) not in seen:
                    ref_color = matrix[i][j]
                    colors[ref_color]+=1
                    q=deque([(i,j)])
                    while q:
                        cur=q.popleft()
                        ci,cj=cur
                        if matrix[ci][cj] != ref_color or cur in seen: continue
                        seen.add(cur)
                        for ni,nj in get_neighbors(ci,cj):
                            q.append((ni,nj))
        freq=sorted(list(colors.values()))
        mx = freq.pop()
        return sum(freq)
Rookie Mistake
-------------
Assuming there's always an R, if there's no B we can always reach the sides.
Otherwise, if the R is not trapped between two B's, we can reach one of the sides.
-------------
class Solution:
    def solve(self, s):
        if "B" not in s: return True
        return not s.index("B") < s.index("R") < s.rindex("B")
Sum of the Deepest Nodes
-------------
We can do BFS, and only keep the sum of the last layer we iterate through.
-------------
from collections import defaultdict,deque
class Solution:
    def solve(self, root):
        if not root: return 0
        q=deque([root])
        ans=0
        while q:
            ans=0
            for _ in range(len(q)):
                cur=q.popleft()
                ans+=cur.val
                for c in (cur.left, cur.right): 
                    if c: q.append(c)
        return ans
Contiguous Intervals
-------------
We iterate over the sorted numbers, each time the present number isn't equal to the past number, we append the interval. 

Trick so you don't have to deal with edge cases: add big value at end, so you don't need to check if you reached the end, or if the list is at least length 2.
-------------
class Solution:
    def solve(self, nums):
        nums.sort()
        nums.append(1e9)
        ans=[]
        l=nums[0]
        for i in range(1,len(nums)):
            if nums[i] != nums[i-1] + 1:
                ans.append([l, nums[i-1]])
                l=nums[i]
        return ans
Justify Text
-------------
First step: 
Take as many words as you can on a line. The formula for this is this: the length of all the words + the length of the next word + the space in between (the length of the line) must be less or equal to k.
Second step:
Compute the remaining space by subtracting the total length from words from k. If there is one word append the space to it. If there are many words, divide the remaining space in len(line)-1, the number of spaces between words. Take the remainder and sequentially add it to words starting from the start.
-------------
class Solution:
    def solve(self, words, k):
        ans=[]
        i=0
        while i<len(words):
            line=[]
            while i<len(words) and (sum(map(len,line)) + len(line) + len(words[i])) <= k:
                line.append(words[i])
                i+=1
            remaining_space = k-sum(map(len,line))
            if len(line) == 1:
                line[0]+=" "*remaining_space
                ans.append(line[0])
            else:
                space_len,space_rem = divmod(remaining_space,len(line)-1)
                for j in range(space_rem):
                    line[j] += " "
                ans.append((" "*space_len).join(line))
        return ans
            
Atbash Cipher
-------------
Shorter version of my previous post.

We create a dictionary mapping a to z, b to y, etc. And then we map the text to this dictionary.
-------------
from string import ascii_lowercase as a
class Solution:
    def solve(self, text):
        d = dict(zip(a, a[::-1]))
        return "".join(d[c] for c in text)
Verify Max Heap
-------------
We can simply check the rules specified in the problem statement.
-------------
class Solution:
    def solve(self, nums):
        for i in range(len(nums)//2):
            for j in range(1,3):
                if 2*i+j >= len(nums): break
                if nums[i]<nums[2*i+j]: return False
        return True
Remove One Letter
-------------
haha Counter goes brrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr
-------------
from collections import Counter
class Solution:
    def solve(self, s0, s1):
        c = Counter(s0)-Counter(s1)
        if sum(c.values()) != 1: return -1
        return s0.index(list(c.keys())[0])

Level Order Alternating
-------------
We can simply do breadth-first search, and track when to reverse the values with a boolean.
-------------
class Solution:
    def solve(self, root):
        ans=[root.val]
        q=[root]
        level=[]
        reverse=True
        while q:
            while q:
                node=q.pop(0)
                if node.left: level.append(node.left)
                if node.right: level.append(node.right)
            ans += values(level) if not reverse else values(level[::-1])
            q=level
            level=[]
            reverse = not reverse
        return ans
            
def values(arr):
    return list(map(lambda x:x.val, arr))
Non-Decreasing Digits
-------------
Imagine a 2 digit number: 43. If it doesn't satisfy the conditions, we subtract one to the left number and set the second one to 9, because 9 will always respect the constraint and it is the closest number going down.

When we have a longer number: 123123, and we find a decreasing pair of digits (3,1), we can repeat the process and get: 122923. But now we have the same problem with (9,2). Notice how we skipped 122999 by subtracting to the original number. In fact, we can always set everything to 9 from the leftmost number where the non-decreasing constraint is not respected, so we can find the leftmost digit that break the constraint and set everything to its right to 9, and then subtract one from it.
-------------
class Solution:
    def solve(self, n):
        digits=[int(x) for x in str(n)]
        left_bound=None
        for i in range(len(digits)-1,0,-1):
            if digits[i]<digits[i-1]:
                left_bound=i
                digits[i-1]-=1
        if left_bound:
            for i in range(left_bound, len(digits)):
                digits[i]=9
        return int("".join(map(str,digits)))
Wolves of Wall Street
-------------
We buy and sell the next day, and if the result was negative we just pretend nothing happened :) don't try this at home
-------------
class Solution:
    def solve(self, prices):
        return sum(max(0,prices[i]-prices[i-1]) for i in range(1,len(prices)))

Height Balanced Tree
-------------
for every node in the tree, the absolute difference of the height of its left subtree and the height of its right subtree is less than two. and children are balanced as well.
-------------
class Solution:
    def solve(self, root):
        def dfs(node,d=0):
            if not node: return True, d-1
            left_bal, ld = dfs(node.left,d+1)
            right_bal, rd = dfs(node.right, d+1)
            return left_bal and right_bal and abs(ld-rd) < 2, max(d,ld,rd)
        return dfs(root)[0]

Popularity
-------------
The number of paths going through (a,b) is the number of children nodes counting from b (e) times the rest of the nodes.

Explained in detail in this video (I made :D): https://www.youtube.com/watch?v=6s0ZRkJDeRc
-------------
from collections import defaultdict
from functools import lru_cache
class Solution:
    def solve(self, edges):
        adj=defaultdict(list)
        node_count=len({node for edge in edges for node in edge})
        ans=[]
        for s,e in edges: adj[s].append(e)
        @lru_cache(None)
        def children_count(node):
            return sum(children_count(nei)+1 for nei in adj[node])
        for s,e in edges:
            ends=children_count(e)+1
            starts = node_count-ends
            ans.append(starts*ends)
        return ans
The Meeting Place Sequel
-------------
Find the position of each person (value 2). 

For each person, keep a queue and apply one BFS tick to each person sequentially. When the BFS of someone intersects with the BFS of someone else, you have found the cost it takes to meet up with them. Return the max cost of any pair of person meeting up.
-------------
class Solution:
    def solve(self, matrix):
        ppl={}
        sets={}
        for i,r in enumerate(matrix):
            for j,v in enumerate(r):
                if v==2: 
                    ppl[(i,j)] = [(i,j)]
                    sets[(i,j)] = set()
                
        if len(ppl)==0: return 0
        cost={src_pos: 0 for src_pos in ppl.keys()}
        done={src_pos: False for src_pos in ppl.keys()}
        while not all(done.values()):
            for src_pos,q in ppl.items():
                if done[src_pos]: continue
                seen=sets[src_pos]
                for i in range(len(q)):
                    ci,cj = q.pop(0)
                    if (ci,cj) in seen: continue
                    seen.add((ci,cj))
                    neighbors = get_neighbors(ci,cj,matrix)
                    for ni,nj in neighbors:
                        q.append((ni,nj))
            for src_pos in ppl.keys():
                if done[src_pos]: continue
                seen=sets[src_pos]
                if all(len(seen&x)>0 for x in sets.values()):
                    done[src_pos]=True
                    continue
                cost[src_pos]+=1
        return max(cost.values())
        
    
def get_neighbors(i,j,matrix):
    directions=[(1,0),(-1,0),(0,1),(0,-1)]
    n=[]
    for di,dj in directions:
        ni,nj = i+di, j+dj
        if ni>=0 and nj>=0 and ni<len(matrix) and nj<len(matrix[0]) and matrix[ni][nj] != 1:
            n.append((ni,nj))
    return n
                        

Movie Theatres
-------------
We iterate chronogically through events (start of movie or end of movie). If the event type is start of movie, we increment the counter of movies running simultnaneously by one, otherwise a movie has ended and we decrement it.

We keep track of the maximum number of movies and return it.
-------------
class Solution:
    def solve(self, intervals):
        mx=cnt=0
        a=[]
        a+=list(map(lambda x: (x[0], 1), intervals))
        a+=list(map(lambda x: (x[1], -1), intervals))
        a.sort()
        for _,inc in a:
            cnt += inc
            mx=max(mx,cnt)
        return mx
Class Scheduling
-------------
Classic approach to this kind of interval problem.

First we sort by end, guaranteeing that we take the class that will be freed the soonest. Then, we take  classes as long as they don't intersect with the last taken class.
-------------
class Solution:
    def solve(self, times):
        times.sort(key=lambda x: x[1])
        last=-1
        ans=0
        for start,end in times:
            if start>last:
                ans+=1
                last=end
        return ans

K Distinct Window
-------------
We keep track of the distinct values in the window using a Counter. We increment the frequency of a number when it enters the window and decrement it as it leaves, appending the number of distinct numbers to our answer each time.
-------------
from collections import Counter
class Solution:
    def solve(self, nums, k):
        c=Counter()
        for i in range(k):
            c[nums[i]]+=1
        ans=[]
        for i in range(k,len(nums)):
            ans.append(len(c))
            c[nums[i]]+=1
            c[nums[i-k]]-=1
            if c[nums[i-k]]==0: del c[nums[i-k]]
        ans.append(len(c))
        return ans

Balanced Brackets
-------------
Two constraints apply for balanced brackets:

1. Same number of opening and closing brackets,
2. You never close more brackets than you open.
-------------
class Solution:
    def solve(self, s):
        cnt=0
        for c in s:
            cnt += 1 if c == "(" else -1
            if cnt<0: return False
        return cnt==0

Longest Path in a Graph
-------------
The longest path starting from a node is the longest path starting from its neighbors plus one. In order to avoid recomputing the longest path starting from any node, we can memoize the result.
-------------
from functools import lru_cache
class Solution:
    def solve(self, graph):
        @lru_cache(None)
        def dfs(i):
            if not graph[i]: return 0
            return max(dfs(j) for j in graph[i])+1
        return max(dfs(i) for i in range(len(graph)))

Maximum Non-Adjacent Tree Sum
-------------
We need to keep track of two sums, one that includes the child node and one that doesn't. 

Notice how when compute the first value, we use node.val. In that case, we can't use the max sum that contain the child nodes x1 and x2.

If we are not using the current node in the sum, we are free to use the child nodes or not, so we return the sum of the max values of each child.
-------------
class Solution:
    def solve(self, root):
        def dfs(node):
            if not node: return 0,0
            x1,x2 = dfs(node.left)
            y1,y2 = dfs(node.right)
            return node.val+x2+y2, max(x1,x2)+max(y1,y2)
        return max(dfs(root))
                

Consecutive Duplicates
-------------
Python's groupby function groups consecutive equals value for you. Why do any work when python does it for you?

-------------
from itertools import groupby
class Solution:
    def solve(self, s):
        return "".join(k for k,_ in groupby(s))

3 and 7
-------------
Mutiples of three:
0,3,6,9,12,15,18,21,...

Mutiples of seven:
0,7,14,21,...

By removing 7 or 14, we fall back on a multiple of 21, which is also a multiple of 3.

In the general case ax+by = c where a,b,c are integers, check out linear diophantine equations:

https://brilliant.org/wiki/linear-diophantine-equations-one-equation/
-------------
class Solution:
    def solve(self, n):
        return any((
            not n%3,
            n>=7 and not (n-7)%3,
            n>=14 and not (n-14)%3
        ))

Painting Houses
-------------
For each cell in a row, we take the minimum value from the previous row excluding the current column and add it to the current cell. 

If we do that naively, we will timeout, so one trick we can do is only keep the two minimum values - taking the second value if the column of the smallest value is the same as the current cell, otherwise taking the smallest value.
-------------
class Solution:
    def solve(self, matrix):
        a,b=1e9,1e9
        ia,ib=-1,-1
        for i in range(len(matrix[0])):
            n = matrix[0][i]
            if n < a: 
                a,b = n,a
                ia,ib = i,ia
            elif n<b: 
                b=n
                ib=i
        for i in range(1,len(matrix)):
            cura,curb=1e9, 1e9
            curia, curib=-1,-1
            for j in range(len(matrix[0])):
                mn=a if j != ia else b
                matrix[i][j] += mn
                v = matrix[i][j]
                if v < cura:
                    cura, curb = v, cura
                    curia, curib = j, curia
                elif v < curb:
                    curb = v
                    curib = j
            a,b=cura,curb
            ia,ib = curia,curib
        return a

8-Puzzle
-------------
A* solution.

First we can check if the problem is solvable with the trick described here: https://www.geeksforgeeks.org/check-instance-15-puzzle-solvable/.

Then we use our A* path finding algorithm, using the number of misplaced numbers as an heuristic.
-------------
from heapq import heappush, heappop
class Solution:
    def solve(self, board):
        board = tuple([x for r in board for x in r])
        target = tuple(range(9))
        if inversions(board)&1: return -1
        d=dist(board)
        q=[(d,0,board)]
        seen=set()
        while q:
            cost,swaps,state =heappop(q)
            if state==target: return swaps
            if state in seen: continue
            seen.add(state)
            for next_state in get_neighbors(state):
                heappush(q,(dist(next_state)+swaps+1,swaps+1,next_state))

def inversions(board):
    sm=0
    for i in range(len(board)):
        if not board[i]: continue
        for j in range(i+1, len(board)):
            if not board[j] : continue
            if board[i]>board[j]:
                sm+=1
    return sm
    
def dist(board):
    return sum(1 for i,x in enumerate(board) if x!=0 and i!=x)

def get_neighbors(board):
    board=list(board)
    i = board.index(0)
    if i % 3 > 0:
        board[i], board[i-1] = board[i-1], board[i]
        yield tuple(board)
        board[i], board[i-1] = board[i-1], board[i]
    if i % 3 < 2:
        board[i], board[i+1] = board[i+1], board[i]
        yield tuple(board)
        board[i], board[i+1] = board[i+1], board[i]
    if i//3 > 0:
        board[i], board[i-3] = board[i-3], board[i]
        yield tuple(board)
        board[i], board[i-3] = board[i-3], board[i]
    if i//3 < 2:
        board[i], board[i+3] = board[i+3], board[i]
        yield tuple(board)
        board[i], board[i+3] = board[i+3], board[i]

Distributed Systems
-------------
Dijkstra's algorithm for shortest path in a graph. Similar to BFS, but we use a min-heap that uses the cost as the key, so we greedily process the lowest cost node at any time.
-------------
from heapq import heappush, heappop
class Solution:
    def solve(self, n, edges):
        adj_list=[[] for _ in range(n+1)]
        for start,end,cost in edges:
            adj_list[start].append((cost,end))
            adj_list[end].append((cost,start))
        q=[(0,0)]
        seen=[False for _ in range(n+1)]
        mcost=0
        while q:
            cost,node=heappop(q)
            if seen[node]: continue
            seen[node]=True
            mcost=max(mcost,cost)
            for ncost, nnode in adj_list[node]:
                heappush(q,(cost+ncost, nnode))
        return mcost

Odd Number of Digits
-------------
The number of digits in a number is represented by the its by log base 10. If its even, we have an odd number of digits.
-------------
from math import log
class Solution:
    def solve(self, nums):
        return sum(1 for n in nums if not int(log(n,10))&1)

Largest Tree Sum Path
-------------
For each node, we can check whats the path with the greatest sum that goes through it by checking the max value of the following possibilites:

- The path starting at the node (if children are negative),
- The path coming from the left child,
- The path coming from the right child,
- The path coming from one children, and going down in the next.

Then, the maximum path coming out of the node can either come from the left, the right or start at the node.
-------------
# class Tree:
#     def __init__(self, val, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def solve(self, root):
        mx=0
        def dfs(node):
            nonlocal mx
            if not node: return 0
            l=dfs(node.left)
            r=dfs(node.right)
            mx=max(mx,l+node.val, r+node.val, l+r+node.val)
            return max(l+node.val,r+node.val,node.val)
        dfs(root)
        return mx

Valid N Queens
-------------
We can validate each of the three constraints to this problem in one line each.

To validate that there is exactly one queen per row, we return False if any row contains more (or less) than one queen.
To validate that there is exactly one queen per column, we repeat the same process as above on the tranposed matrix.
To validate that there is only one queen per diagonal, we can use a cool trick. For each unique diagonal in a grid, the value of j-i will be constant, because when we iterate over a diagonal, we add one to both j and i.
Here's an example of grid[i][j] = j-i:
```
i/j 0  1  2
 0  0  1  2
 1 -1  0  1
 2 -2 -1  0
```
So we can create a set of all unique (j-i) values and check that it equals the number of required queens, N (the length of the matrix).

To check for backward diagonals, we can do the same process with (i+j):
```
i/j 0  1  2
 0  0  1  2
 1  1  2  3
 2  2  3  4
```
-------------
class Solution:
    def solve(self, matrix):
        if any(row.count(1) != 1 for row in matrix): return False
        if any(col.count(1) != 1 for col in zip(*matrix)): return False
        if len(set(j-i for i,row in enumerate(matrix) for j,queen in enumerate(row) if queen)) != len(matrix): return False
        return len(set(j+i for i,row in enumerate(matrix) for j,queen in enumerate(row) if queen)) == len(matrix)

Bob's Game
-------------
We count the number of odd numbers in the list. If we sum two odd numbers together, the result will be even - so the optimal number of moves if the number of odds is divisible by two. 

If there is an odd number of odd numbers - we get stuck with one odd number at the end we can't get rid of.
-------------
class Solution:
    def solve(self, nums):
        odds = sum(1 for n in nums if n&1)
        if odds&1: return -1
        return odds//2

Narcissistic Number
-------------
Use generator expressions to save space! Use strings to iterate over digits and do magic.
-------------
class Solution:
    def solve(self, n):
        s=str(n)
        return n==sum(int(x)**len(s) for x in s)

Smallest Sublist Sum at Least Target
-------------
O(N^2) with prefix sums is good enough if you write it in C++ :). Alex's answer using what I think to be a monoqueue of prefix sums is too mind-bending for me.
-------------
#include "solution.hpp"
#include <bits/stdc++.h>
using namespace std;


int Solution::solve(vector<int>& nums, int target) {
    int ps[nums.size()] = {0};
    ps[0]=nums[0];
    for (int i = 1; i<nums.size(); i++) {
        ps[i]=ps[i-1]+nums[i];
    }
    for (int k = 0; k<nums.size(); k++) {
        for (int i = 0; i<nums.size()-k; i++) {
            if (ps[i+k]-ps[i]+nums[i]>=target) {
                return k+1;
            }
        }
    }
    return -1;
};

Happy Numbers
-------------
Constant space solution using two variables to detect cycles. If there is a cycle, the fast variable will catch up to the slow one, and the loop will exit. 
-------------
class Solution:
    def solve(self, n):
        slow=fast=n
        fast=f(fast)
        while slow!=fast:
            slow=f(slow)
            fast=f(f(fast))
            if fast == 1: return True
        return False

def f(n):
    return sum(int(x) ** 2 for x in str(n))

Largest Number By Two Times
-------------
Using a "max" heap, we can retrieve the max elements in O(ln) time.
-------------
import heapq
class Solution:
    def solve(self, nums):
        nums=[-x for x in nums]
        heapq.heapify(nums)
        return heapq.heappop(nums) < 2*heapq.heappop(nums)
        # Write your code here

Odd Longest Increasing Subsequence
-------------
The best way to approach this problem is to build on top of sub-problems, starting with the first number in the array, then the second, etc. 

Let's take [10,12,14,3,5,6] for example. First, we consider the sub-problem [10]: what is the longest increasing sequence? Since we only have one number, the answer is one. We also need to keep track of the number of odd numbers, which we can do using a dictionary where the key is the number of odd numbers and the value is the longest increasing sequence. So in this case we will have {0: 1}.

Then for [10,12], we will have [{0:1}, {0:2}], because using 12, we can build on top of the longest increasing sub-sequence of 10 since 12 > 10, but we still have 0 odd numbers.

For [10,12,14]: [{0:1}, {0:2}, {0:3}]
For [10,12,14,3]: [{0:1}, {0:2}, {0:3}, {1:1}]. Note that we can't use any of the previous sequences because three is smaller than all the previous values. 

For [10,12,14,3,4]: [{0:1}, {0:2}, {0:3}, {1:1}, {1:2}]
Finally: [10,12,14,3,4,5]: [{0:1}, {0:2}, {0:3}, {1,1}, {1:2}, {2:3}]

Then we iterate over every dictionary and their keys, checking all the values where the number of odds is greater or equal to k. We take the maximum value.
-------------
from collections import defaultdict
class Solution:
    def solve(self, nums, k):
        lens = [defaultdict(int) for _ in nums]
        for i,n in enumerate(nums):
            lens[i][n&1]+=1
            
        for i in range(len(nums)):
            is_odd = nums[i]&1
            for j in range(i):
                if nums[j]>=nums[i]:continue
                for odd_count,length in lens[j].items():
                    lens[i][odd_count+is_odd]=max(lens[i][odd_count+is_odd], length+1)
        ans=0                
        for d in lens:
            for odd_count,length in d.items():
                if odd_count>=k and length>ans: ans=length
        return ans
            

Shortest String
-------------
If a zero and a one exist in s, it is always possible to find two of them that are side by side and delete them. Can i have upvotes too please?
-------------
class Solution:
    def solve(self, s):
        return abs(s.count("1")-s.count("0"))
Longest Sublist with K Distinct Numbers
-------------
Sliding window solution: we iterate over the string and whenever the constraint is not respected, we know that there's no reason to keep going forward so we start popping characters from the left until the constraints are respected again.
-------------
from collections import Counter
class Solution:
    def solve(self, k, s):
        start=0
        distinct=Counter()
        ans=0
        for i,c in enumerate(s):
            distinct[c]+=1
            while len(distinct)>k:
                old=s[start]
                distinct[old]-=1
                if distinct[old] == 0: 
                    del distinct[old]
                start+=1
            ans=max(ans, i-start+1)
        return ans

Two Lists' Median
-------------
Yeah sure, there's a fancy way of doing it. But this passes the test cases just fine. Maybe this is a lesson in over-engineering?
-------------
class Solution:
    def solve(self, nums0, nums1):
        return median(sorted(nums0+nums1))

def median(a):
    return a[len(a)//2]
Sum of Four Numbers
-------------
Recursive general solution, that applies to an arbitrary amount of numbers. We recursively iterate through every number, either picking it or not. When we reach a leaf, we check if we reached the target sum and count.
-------------
class Solution:
    def solve(self, nums, k):
        def dp(i,rem,cnt):
            if rem==0 and cnt==0: return True
            if i==len(nums) or rem<0 or cnt==0: return False
            return dp(i+1,rem,cnt) or dp(i+1, rem-nums[i], cnt-1)
        return dp(0,k,4)
Outstanding Move
-------------
O(N^2) solution. We compute the result for the original order, then we iterate over each number. For each number, if we want to move it to a position, we add its value once per index moved, and we subtract each values met. If we move to the left, we subtract the value for each index and we add each number met.
-------------
class Solution:
    def solve(self, nums):
        orig = compute(nums)
        off=0
        for i,n in enumerate(nums):
            cur=0
            for j in range(i+1, len(nums)):
                cur+=n
                cur-=nums[j]
                off=max(off,cur)
        for i,n in enumerate(nums):
            cur=0
            for j in range(i-1, -1, -1):
                cur-=n
                cur+=nums[j]
                off=max(off,cur)
        return orig+off
def compute(lst):
    return sum((i+1)*v for i,v in enumerate(lst))

Linked List Intersection
-------------
I didn't read the problem so I didn't know the linked lists were already sorted, so I just shoved everything into a set and made a new linked list.
-------------
# class LLNode:
#     def __init__(self, val, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def solve(self, l0, l1):
        s=list(sorted(set(map(val, it(l0)))&set(map(val, it(l1)))))
        head=prev=LLNode(None)
        for v in s:
            prev.next=LLNode(v)
            prev=prev.next
        return head.next
        
def val(n):
    return n.val
    
def it(n):
    while n:
        yield n
        n=n.next

Bear of Wall Street
-------------
Classic DP problem solved with Top-down approach for simplicity.

For each price point:
- if we're holding a stock we try doing nothing and skipping the current day, or selling and waiting one day.
- If we're not holding a stock, we try doing nothing and skipping the current day, or buying at the current price.

Video explanation: https://www.youtube.com/watch?v=upsJfSAE968
-------------
from functools import lru_cache
class Solution:
    def solve(self, prices):
        @lru_cache(None)
        def dp(i=0, holding=False):
            if i >= len(prices): return 0
            if not holding:
                return max(dp(i+1, holding), dp(i+1,True)-prices[i])
            if holding:
                return max(dp(i+1, holding), dp(i+2,False)+prices[i])
        return dp()
                
Linked List to ZigZag Tree Path
-------------
Recursive solution: We set current node as root, and check the next node to see if its smaller and set it as the correct child. Recursively solve for the next nodes.
-------------
class Solution:
    def solve(self, node):
        if not node: return None
        root=Tree(node.val)
        if node.next:
            if node.next.val<node.val:
               root.left = self.solve(node.next)
            else:
               root.right = self.solve(node.next)
        return root

Twin Trees
-------------
We recursively check if the corresponding nodes from each tree are identical. The first two lines handles cases where structure is different.
-------------
class Solution:
    def solve(self, n1,n2):
        if not n1 and not n2: return True
        if not n1 or not n2: return False
        return n1.val == n2.val and self.solve(n1.left, n2.left) and self.solve(n1.right, n2.right)
    
Leaves in Same Level
-------------
We can use a generator to generate all the leaves depth, and check if there is only one unique depth using a set.
-------------
class Solution:
    def solve(self, root):
        return len({x for x in leaves_depth(root)})==1

def leaves_depth(node,depth=0):
    if not node.left and not node.right: yield depth
    if node.left: yield from leaves_depth(node.left,depth+1)
    if node.right: yield from leaves_depth(node.right,depth+1)

Bit Sum
-------------
To minimize the sum, we want to flip the rightmost 0 bits. So we can iterate over the bits of every numbers, and then greedily takes the k rightmost bits.

I also cheesed it a bit by considering 32 bits for all numbers, and all bits left of the last one bit are also zeroes.
-------------
from collections import defaultdict
class Solution:
    def solve(self, nums, k):
        bitcount = defaultdict(int)
        for n in nums:
            b = bin(n)[2:]
            for i,bit in enumerate(b[::-1]):
                if bit == "0": bitcount[i]+=1
            for j in range(i+1, 32):
                bitcount[j]+=1
        s=sum(nums)
        p = sorted(bitcount.items())
        while k > 0:
            bit,cnt = p.pop(0)
            n = min(k,cnt)
            s += n * 2**bit
            k-=n
        return s % (10 ** 9 + 7)

Connell Sequence
-------------
This problem challenges your ability to google Connell sequence and finding this link: https://mathworld.wolfram.com/ConnellSequence.html#:~:text=The%20Connell%20sequence%20is%20the,16%2C%2017%2C%20...
-------------
from math import sqrt
class Solution:
    def solve(self, n):
        n+=1
        return 2*n - (1+sqrt(8*n-7))//2

Small Large Medium
-------------
https://leetcode.com/problems/132-pattern/submissions/
-------------
class Solution:
    def solve(self, nums):
        mins=[1e9 for _ in nums]
        for i,n in enumerate(nums):
            mins[i]=n
            if i > 0 and mins[i-1]<mins[i]: mins[i]=mins[i-1]
        stk=[]
        for i in range(len(nums)-1,-1,-1):
            while stk and stk[-1] <= mins[i]: stk.pop()
            if stk and stk[-1]<nums[i]: return True
            stk.append(nums[i])
        return False
Forest Detection
-------------
To validate that we have a "forest", we can use the rule that there should be only one path between every node. One way to validate this is to do BFS from every unexplored node, and each time you visit a neighbor, you remove the edge between them. If you ever fall on a node you already explored, there is more than one path to this node so this is not a tree.
-------------
from collections import defaultdict
from collections import deque
class Solution:
    def solve(self, edges):
        adj_list=defaultdict(set)
        nodes=set()
        for s,e in edges:
            adj_list[s].add(e)
            adj_list[e].add(s)
            nodes.add(s)
            nodes.add(e)
        seen=set()
        def bfs(start):
            q=deque([start])
            while q:
                cur=q.popleft()
                for nei in set(adj_list[cur]):
                    if nei in seen: return False
                    seen.add(nei)
                    adj_list[nei].remove(cur)
                    adj_list[cur].remove(nei)
                    q.append(nei)
            return True
        for n in nodes:
            if n not in seen:
                seen.add(n)
                if not bfs(n): 
                    return False
        return True
DDoS Protection
-------------
We keep track of a global queue and a queue per user. We process requests ordered by timestamp, for each request we remove all the ones earlier than 60 seconds. If any queue is larger than u or g, we skip the current request.
-------------
from collections import defaultdict
class Solution:
    def solve(self, requests, u, g):
        requests.sort()
        requests.sort(key=lambda x: x[1])
        user_qs=defaultdict(list)
        global_q=[]
        ans=0
        for req in requests:
            user_id, time = req
            lim = time-60
            user_q=user_qs[user_id]
            while global_q and global_q[0]<=lim:
                global_q.pop(0)
            while user_q and user_q[0]<=lim:
                user_q.pop(0)
            if len(global_q)<g and len(user_q)<u:
                ans+=1
                user_q.append(time)
                global_q.append(time)
        return ans
                

K Maximum Sums
-------------
We build a prefix sum array to be able to query the sum between two positions easily. Then we compute the sum between every possible interval and put it into a heap. We take the k largest sums from the heap.
-------------
from heapq import heappop,heappush
class Solution:
    def solve(self, nums, k):
        ps=[0 for _ in range(len(nums)+1)]
        for i,v in enumerate(nums):
            ps[i+1]=v+ps[i]
        hp=[]
        for i in range(len(ps)):
            for j in range(i+1,len(ps)):
                heappush(hp,-(ps[j]-ps[i]))
        return list(reversed([-heappop(hp) for _ in range(k)]))
One Integer
-------------
To minimize the sum, we have to take the smallest numbers available at each iteration. We can use a min-heap to achieve this.
-------------
from heapq import heappush, heappop, heapify
class Solution:
    def solve(self, nums):
        heapify(nums)
        ans=0
        while len(nums)>1:
            a,b = heappop(nums), heappop(nums)
            ans+=a+b
            heappush(nums,a+b)
        return ans
Labyrinthian Possibilities
-------------
2D DP solution: 
If theres a wall: there are 0 way to reach the current position
Otherwise: the number of ways to reach current position is the number of ways to reach the top position plus the number of ways to reach the left position.

-------------
class Solution:
    def solve(self, matrix):
        if matrix[0][0]: return 0
        matrix[-1][-1]=0
        dp = [[0]*len(matrix[0]) for _ in matrix]
        dp[0][0]=1 
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if matrix[i][j]: continue
                if i>0: dp[i][j] = dp[i-1][j]
                if j>0: dp[i][j] += dp[i][j-1]
        return dp[-1][-1] % (10 ** 9 + 7)

123 Number Flip
-------------
We want to find the leftmost digit that isn't a three and flip it to a three.

The reason it works is that every increase in value in a digit to the left increase the value 10 times more than the next digit.
-------------
class Solution:
    def solve(self, n):
        i=0
        s=str(n)
        for i,c in enumerate(str(n)):
            if s[i]!="3":
                s=s[:i]+"3"+s[i+1:]
                break
        return int(s)

Domino Placement
-------------
If we fill the board with vertical dominos, we can fit n dominos in width and m//2 dominos in height. If the height is uneven, we have to put dominos sideways on the last row, so we divide the width by two.
-------------
class Solution:
    def solve(self, n, m):
        return (n*(m-(m&1))//2)+(m&1)*n//2

Minimum Parsing Tree
-------------
This is a recursive complete-search solution, that goes as follows:

We start with pointers (i,j) that represent the start and the end of the current interval.

[ 0, 5, 8, 9 ]

..^ i ....... ^ j

Then, we iterate over each position (k) between those two pointers. This will be the split position.

[ 0, 5, 8, 9 ]

..^i ^k.... ^j

For every split position (k), we make two recursive calls. Once for the left interval [i,k] and once for the right interval [k,j]. This represents potential children of the current node. In this example, the children are [0,5] and [5,9].

When we reach a position where the interval is of size 2 (when i & j are next to eachother):

[ 0, 5, 8, 9 ]

.^i ..^j

We compute the interval of the node with arr[j]-arr[i].

When we receive the value of the children, we pick the one with the minimum interval, we add the size of the current interval and return the result.

With the algorithm completed, we now need to add memoization, because there are many overlapping subproblems. For example:

[1,2,3,4,5,6]

Eventually we will need to compute the value [1,2], [1,3], [1,4] and [1,5]. When we compute [1,5], we will add the result of [1,4] and [4,5]. When we computer [1,4], we will add the result of [1,3] and [3,4], etc...

Python's functools package offers lru\_cache, that detects when a function was called with the exact same parameters, and returns the value that was computed by those parameters. It solves our problem of overlapping subproblems and we no longer have a time limit exceeded error.

Thanks for coming to my TED talk.

-------------
from functools import lru_cache
class Solution:
    
    def solve(self, breakpoints):
        @lru_cache(None)
        def divide(i,j):
            if j == i+1:
                return breakpoints[j]-breakpoints[i]
            min=1e9
            for k in range(i+1, j):
                res=divide(i,k)+divide(k,j)
                if res < min:
                    min=res
            return min+breakpoints[j]-breakpoints[i]
        return divide(0,len(breakpoints)-1)
        # Write your code here

Longest Common Substring
-------------
Check if ith character in one string A is equal to jth character in string B

Case 1: both characters are same

LCS[i][j] = 1 + LCS[i-1][j-1] (add 1 to the result and remove the last character from both the strings and check the result for the smaller string.)

Case 2: both characters are not same.

LCS[i][j] = 0

At the end, traverse the matrix and find the maximum element in it, This will the length of Longest Common Substring.

https://algorithms.tutorialhorizon.com/dynamic-programming-longest-common-substring/
-------------
class Solution:
    def solve(self, s0, s1):
        dp=[[0 for _ in s1] for _ in s0]
        for i in range(len(s1)):
            dp[0][i] = s1[i]==s0[0]
        for i in range(len(s0)):
            dp[i][0] = s0[i]==s1[0]
        for i in range(1,len(s0)):
            for j in range(1,len(s1)):
                if s0[i]==s1[j]:
                    dp[i][j] = 1+dp[i-1][j-1]
        return max(max(r) for r in dp)
Trailing Zeros
-------------
The key insight to the types of problem asking for the trailing number of zeroes is the following.

The number of trailing zeroes is the number of times 10 can divide a number. The number of tens in a number can be found by doing its prime factorization: each ten is composed of prime factors 2 and 5, so the number of pairs of 2 and 5 in the prime factors of a number will give the number of trailing zeroes.

Now, we must find the smallest value that can be divided by numbers [1,k], otherwise known as the least common multiple (lcm). Let's take an example (k=5):
lcm(1,2,3,4,5) = lcm(1,lcm(2,lcm(3,lcm(4,5))))
lcm(4,5) =20
lcm(3,20)=60
lcm(2,60)=60
lcm(1,60)=60 
A key insight here is that lcm(2,4) = 4, so we can ignore the 2 completely. The reason for this is that 4 is a multiple of 2.
lcm(1,3,4,5)=1x3x4x5=60 (No number is a multiple of another).

How does this help us counting the number of 10's? Well, if we can eliminate numbers for which one of their multiples is present in the series, it means if we have 5,10,15,20, we can eliminate 5,10,15 and just keep the largest number (20), and its prime factors are 2x2x5. In order to gain another 5, we must reach the next power of 5, 25:

25 = 5*5. => k=25 will have two trailing zeroes because we have two 5's. 
We can assume there will be enough 2's in the series because 2 is more frequent than 5, (2,4,6,8,...) vs (5,10,15,...)

Hopefully this gives you the intuition (smiley face).
-------------
from math import log
class Solution:
    def solve(self, k):
        return int(log(k,5))

N Queens Puzzle
-------------
Other solutions are pretty clever, but for completeness' sake, here's a backtracking implementation that solves the problem.
-------------
class Solution:
    def solve(self, matrix):
        self.matrix=matrix
        self.N = len(matrix)
        self.rows=set()
        self.cols=set()
        self.diags=set()
        self.backdiags=set()
        for i,r in enumerate(matrix):
            for j,v in enumerate(r):
                if v:
                    if not self.add_pos(i,j):
                        return False
        return self.backtrack()
        
    def pos_unused(self,i,j):
        return all((
            i not in self.rows,
            j not in self.cols,
            (j-i) not in self.diags,
            (j+i) not in self.backdiags
        ))
        
    def add_pos(self,i,j):
        if not self.pos_unused(i,j): 
            return False
        self.rows.add(i)
        self.cols.add(j)
        self.diags.add(j-i)
        self.backdiags.add(j+i)
        return True
        
    def remove_pos(self,i,j):
        self.rows.remove(i)
        self.cols.remove(j)
        self.diags.remove(j-i)
        self.backdiags.remove(j+i)
        
    def seek(self,i=0,j=0):
        while i<self.N:
            if self.pos_unused(i,j):
                yield i,j
            j+=1
            i+=j//self.N
            j=j%self.N
        
    def done(self):
        return len(self.rows)==self.N
        
    def backtrack(self,i=0,j=0):
        if self.done():  return True
        for i,j in self.seek(i,j):
            self.add_pos(i,j)
            if self.backtrack(i+1,0): return True
            self.remove_pos(i,j)
        return False
    

Reverse Words Sequel
-------------
Inspired by Alex, but maybe a little clearer? Build a stack with words, then undo the stack, adding the delimiters at the same time.

k is True means the group is delimiters.
-------------
from itertools import groupby
class Solution:
    def solve(self, sentence, delimiters):
        words=[]
        ans=""
        for k,g in groupby(sentence, lambda x: x in delimiters):
            if not k:
                words.append("".join(g))
        for k,g in groupby(sentence, lambda x: x in delimiters):
            if k:
                ans+="".join(g)
            else:
                ans+=words.pop()
        return ans

Uber Pool
-------------
Heap-based solution, O(n log n)

Given that the trips are already sorted by start, we can iterate through the trips and add their capacity to a counter. 

We add the end of each trip to a heap. For each following trip, we will check if we have to drop off anyone by checking the top of the min-heap and looking if the end of the trip is less or equal than the start of the current.
-------------
from heapq import heappop, heappush
class Solution:
    def solve(self, trips, capacity):
        cnt=0
        dropoff=[]
        for start,end,num in trips:
            while dropoff and dropoff[0][0] <= start:
                cnt-=dropoff[0][1]
                heappop(dropoff)
            cnt+=num
            if cnt > capacity:
                return False
            heappush(dropoff, (end,num))
        return True

Partition Tree
-------------
We recurse on each node verifying its leaf status by checking if it has any children. If not, we increment leaf counter otherwise non-leaf counter.
-------------
class Solution:
    def solve(self, root):
        leaves=0
        notleaves=0
        def dfs(node):
            nonlocal leaves
            nonlocal notleaves
            if not node: return
            if not node.left and not node.right: 
                leaves+=1
            else:
                notleaves+=1
            dfs(node.left)
            dfs(node.right)
        dfs(root)
        return (leaves,notleaves)

Inorder Successor
-------------
First step is to find t, so we go left if t is smaller, right if t is larger.

When we find t, if it has a right node, we go right then completely left to find the smallest value greater than t.
If there is no right node, we need to remember the last time we went left in the tree when searching for t, it is the last value that was greater than t (the hi parameter).
-------------

class Solution:
    def solve(self, root, t,hi=None):
        if t<root.val:
            return self.solve(root.left,t,root.val)
        elif t>root.val:
            return self.solve(root.right,t,hi)
        else:
            if root.right:
                n=root.right
                while n.left: n=n.left
                return n.val
            return hi

Longest Increasing Subsequence
-------------
O(n log n) approach: https://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/

We keep an array (dp), where dp[i] represents the last value of the longest increasing subsequence of size (i+1). If our current value (n) is greater than the last value, we can make a longer subsequence by appending n to our dp array. Since it has to respect the LIS rules, our dp array will be strictly increasing, so we can binary search on it to find the position of the current n. 
-------------
from bisect import bisect_left
class Solution:
    def solve(self, nums):
        dp=[]
        for n in nums:
            i=bisect_left(dp, n)
            if i==len(dp):
                dp.append(n)
            else:
                dp[i]=n
        return len(dp)

Consecutively Descending Integers
-------------
Brute-force all initial number lengths. For each number, we check if its equal to the previous one minus one, and then we jump to the next number. If the current number is a power of ten, we need to reduce the size of the next number by one (except for one and zero).
-------------
from math import log
class Solution:
    def solve(self, s):
        def dfs(i,j,prev):
            if i>=len(s): return True
            cur=s[i:j]
            cur_num=int(cur)
            if prev is not None and cur_num != prev-1: return False
            ni = j
            nj = ni+len(cur)
            if cur_num not in (1,0) and log(cur_num,10).is_integer():
                nj-=1
            return dfs(ni,nj, int(cur))
        for j in range(1, (len(s)+2)//2):
            if dfs(0,j,None): return True
        return False

Base 3 to Integer
-------------
Why do any work when PYTHON DOES IT ALL FOR YOU???
-------------
class Solution:
    def solve(self, s):
        return int(s,3)

No New Friends
-------------
Two solutions:

- Build a set from all people in friendships and check its length is n
- Check all people (x) in range(n) is in any friendship
-------------
class Solution:
    def solve(self, n, friends):
        # Efficient version
        
        # return len(set(person for group in friends for person in group)) == n
        
        # Simple version
        return all(any(x in f for f in friends) for x in range(n))

Robinhood
-------------
Constant time solution with math.

We can represent this problem by one of the following equation:
T = N * e^x * o^x = N * (e * o)^x, if the cycle ends on the second interest;
T = N * e^x * o^(x-1) = (N/o) * (e * o)^x, if the cycle ends on the first interest.

We can solve for x. In the first equation, x means 2 year have passed.
In the second equation, it means 2*x-1 years have passed.
-------------
from math import log,ceil
class Solution:
    def solve(self, n, e, o, t):
        e=(e+100)/100
        o=(o+100)/100
        return min(2*ceil(log(t/n,e*o)), 2*ceil(log(t/(n/o),e*o))-1)

Decode Message
-------------
Recursive solution with memoization. The number of ways to decode the string from index i is the number of ways to decode the string from index i+1 and i+2, if the next two digits fit in the [1,26] range.
-------------
from functools import lru_cache
class Solution:
    def solve(self, message):
        @lru_cache(None)
        def dp(i):
            if i>=len(message): return 1
            ans = dp(i+1)
            if i<len(message)-1 and 1<=int(message[i:i+2])<=26:
                ans+=dp(i+2)
            return ans
        return dp(0)

24
-------------
Brute-force solution where we try all possible operator combinations in all different orders, build an expression tree and evaluate it.
-------------
import operator
from itertools import permutations, product
OPERATORS=["+","-","*","/"]
class Solution:
    def solve(self, nums):
        for operators in product(OPERATORS,repeat=3):
            for order in permutations(range(3)):
                if compute(operators,order,nums): return True
        return False

class Node:
    fn={
        "+": operator.add,
        "-": operator.sub,
        "*": operator.mul,
        "/": operator.truediv
    }
    def __init__(self, value, left=None, right=None):
        self.value=value
        self.left=left
        self.right=right
    def compute(self):
        if not self.left and not self.right:
            return self.value
        return Node.fn[self.value](self.left.compute(),self.right.compute())

def compute(operators,order,nums):
    nums=[Node(n) for n in nums]
    for idx in order:
        op = operators[idx]
        node=Node(op, nums[idx], nums[idx+1])
        nums[idx],nums[idx+1]=node,node
    try:
        return node.compute() == 24
    except ZeroDivisionError:
        return False
Smallest Difference
-------------
Given a random selection of numbers, there is two ways to optimize the answer:
1. Change the lower bound (min) in the hopes that is goes higher and tightens the interval
2. Change the upper bound (max) in the hopes that is goes lower and tightens the interval

If we sort the lists and start with all the minimum values - we eliminate one possibility. Now the only way to get a better answer is to change the min value, because the max value can only go upwards.

We can use a heap to continually extract the min value from all lists, and save each intermediate results. 
-------------
from heapq import heapify, heappop, heappush
class Solution:
    def solve(self, lists):
        for l in lists:
            l.sort()
        hp = [(l[0],0,i) for i,l in enumerate(lists)]
        heapify(hp)
        hi = max(l[0] for l in lists)
        ans=float('inf')
        while True:
            cur_min,idx,list_idx = heappop(hp)
            ans=min(ans, hi-cur_min)
            if idx == len(lists[list_idx])-1: break
            next_val = lists[list_idx][idx+1]
            if next_val>hi: hi=next_val
            heappush(hp, (next_val, idx+1, list_idx))
        return ans
            
Cutting Binary Search Tree
-------------
HERE'S JOHNNY!

If the node if outside the range, exclude it. Then test each of his children. ez pz 
-------------
class Solution:
    def solve(self, root, lo, hi):
        if not root: return
        if lo > root.val:
            return self.solve(root.right,lo,hi)
        if hi < root.val:
            return self.solve(root.left,lo,hi)
        root.right=self.solve(root.right,lo,hi)
        root.left=self.solve(root.left,lo,hi)
        return root

Parentheses Grouping
-------------
Parentheses are balanced when there is an equal number of opening and closing parentheses. So each time the running count is equal to zero, we are balanced and append another group to our answer.
-------------
class Solution:
    def solve(self, n):
        a=[[]]
        cnt=0
        for c in n:
            cnt += 1 if c=="(" else -1
            a[-1].append(c)
            if cnt==0:
                a.append([])
        return ["".join(x) for x in a if x]
Reverse Graph
-------------
One-line solution goes as follows:

We iterate through each value in the graph, then we build an array by iterating through the graph again, and adding the index of the list if the original index is present in the list.

Makes sense?
-------------
class Solution:
    def solve(self, graph):
        return [[x for x,l in enumerate(graph) if i in l] for i,_ in enumerate(graph)]
Just Average
-------------
We divide all numbers by len(nums)-1, since the average will be the sum of elements divided by the number of elements and we remove one element.

Then we can pick len(nums)-1 numbers from that list and sum them. To check all possibilities, we can do the sum of all values and try subtracting each value to see if we reach k.
-------------
from math import isclose
class Solution:
    def solve(self, nums, k):
        n=len(nums)-1
        nums=[x/n for x in nums]
        s=sum(nums)
        return any(isclose(s-x,k) for x in nums)

Increasing Digits
-------------
Simple recursive solution for the non-math people like me. We iterate over all digits, and keep track of the previous digit and recurse when the current digit is greater. When we reach n == 0 we have a valid solution so we return 1.
-------------
class Solution:
    def solve(self, n, prev=0):
        if n == 0: return 1
        ans=sum(self.solve(n-1,i) for i in range(1,10) if i>prev)
        return ans

Interval Intersection
-------------
Assuming there is an intersection between all intervals, the rightmost start will be less than the leftmost end, and they will define the smallest intersecting interval.
-------------
class Solution:
    def solve(self, intervals):
        s,e=zip(*intervals)
        return max(s), min(e) 

Equalize List
-------------
Two methods to solve this problem: one using binary search to find the minimum of the cost function, and the second using a median.

Explained here: https://www.youtube.com/watch?v=LR2AsgCoPGc
-------------
class Solution: 
    def solve(self, nums, costs):
        return self.solve_math(nums, costs)
        
    def cost_fn(self, nums, costs, target):
        total_cost=0
        for i,n in enumerate(nums):
            dist=abs(target-n)
            total_cost += dist * costs[i]   
        return total_cost
        
    def solve_math(self, nums, costs):
        a = sorted(zip(nums,costs))
        median_pos = sum(costs)//2
        for n, cost in a:
            if cost > median_pos: return self.cost_fn(nums,costs,n)
            median_pos -= cost
        return self.cost_fn(nums,costs,n)
    
    def solve_binarysearch(self, nums, costs):
        def find_peak():
            lo=0
            hi=max(nums)
            while lo<hi:
                mid = (lo+hi)//2
                if self.cost_fn(nums,costs,mid)>self.cost_fn(nums,costs,mid+1):
                    lo=mid+1
                else:
                    hi=mid
            return lo
        t= find_peak()
        return self.cost_fn(nums,costs,t)
                    
            
                

Maximum Sum Removing K Numbers From Ends
-------------
We store prefix sum and suffix sum, then try all possibilities of taking i from left and k-i from right.
-------------
class Solution:
    def solve(self, nums, k):
        ps=[0]
        ss=[0]
        ans=0
        for n in nums:
            ps.append(ps[-1]+n)
        for i in range(len(nums)-1,-1,-1):
            ss.append(ss[-1]+nums[i])
        for i in range(k+1):
            ans=max(ans, ps[i]+ss[k-i])
        return ans
Fleet of Palindromes
-------------
We can spread characters with even frequencies amongst our palindromes as we wish, but we can only have one uneven frequency character per palindrome, so we check if there is less or equal than k uneven frequency. We also assume that len(s) >= k.
-------------
from collections import Counter
class Solution:
    def solve(self, s, k):
        return sum(1 for k,v in Counter(s).items() if v&1) <= k

Count Square Submatrices
-------------
To make a 2x2 square from a 1x1 square, each of its top, left and top-left neighbors must be one:
1 1
1 2
This extends to squares of any dimensions - it is always constraint by the smallest neighbor:
1 2
2 2
Will also give give a square of 2x2, we are missing the top-left cell to make a 3x3.

We can take the min of those three neighbors + 1, get the number of square this cell belongs to, and finally add that number to our answer.
-------------
class Solution:
    def solve(self, matrix):
        ans=0
        for i,r in enumerate(matrix):
            for j,v in enumerate(r):
                if v:
                    if i>0 and j>0:
                        matrix[i][j] += min(matrix[i-1][j],matrix[i][j-1],matrix[i-1][j-1])
                    ans += matrix[i][j]
        return ans

Dividing Station
-------------
One key insight to this problem is that, if a number is divisible by the largest number of a subset, it will be divisible by all the other numbers, because the largest number is a multiple of them.

Following that logic, we can sort the numbers so that each smaller number in a subset are treated first. Now, we keep a list of lists containing the tails of each subset, where the list at subsets[i] is the list of subsets of length i+1 ending with subsets[i]. We iterate backwards until we get a match, maximizing the length for the subset ending with the current number.
-------------
class Solution:
    def solve(self, nums):
        if not nums: return 0
        nums.sort()
        subsets=[[]]
        for i in range(len(nums)):
            found=False
            for j in range(len(subsets)-1,-1,-1):
                ss=subsets[j]
                for n in ss:
                    if nums[i]%n==0:
                        if j==len(subsets)-1:
                            subsets.append([])
                        subsets[j+1].append(nums[i])
                        found=True
                        break
                if found: break
            if not found: subsets[0].append(nums[i])
        return len(subsets)
                
Rotation Groups
-------------
For every word we meet, we increment our answer if its not in our set.
We then generate all rotations of the word and store them in our set.
-------------
class Solution:
    def solve(self, words):
        s=set()
        ans=0
        for w in words:
            if w not in s: ans+=1
            for i in range(len(w)):
                s.add(w[i:] + w[:i])
        return ans

Skip Tasks to Minimize Work
-------------
Simplified bottom-up DP: since our recurrence relation only depends on dp[i-1] and dp[i-2], we only need to keep those two values in memory as a,b and update them sequentially.
-------------
class Solution:
    def solve(self, nums):
        if len(nums) <= 1: return 0
        a,b=nums[0],nums[1]
        for i in range(2,len(nums)):
            a,b = b, nums[i] + min(a,b)
        return min(a,b)

String Construction
-------------
The solution to this problem is similar to a BFS in some ways: we start with an amount of letters and a number of words. Then we iterate over each word, counting the amount of letters A and B. Then, for each word chain we have in our answer, we try adding the current word if it fits, and if result in a greater word count than the previous occurrence of A/B amount.
-------------
class Solution:
    def solve(self, strings, a, b):
        pairs=[]
        for w in strings:
            A = w.count("A")
            B = len(w)-A
            pairs.append((A,B))
        ans={(a,b):0}
        for A,B in pairs:
            cur_ans=dict(ans)
            for (cur_a,cur_b), wc in ans.items():
                if cur_a>=A and cur_b>=B:
                    rem = (cur_a-A, cur_b-B)
                    cur_ans[rem] = max(cur_ans.get(rem,0), wc+1)
            ans=cur_ans
        return max(ans.values())
Upside Down Numbers
-------------
There is always one possible second half of the string, and it is determined by the first half, flipped over. We hardcode the mappings, and handle the middle differently to exclude "6" and "9"s.
-------------
from itertools import product
mapping={
    "0":"0",
    "1":"1",
    "6":"9",
    "8":"8",
    "9":"6"
}
mids=["0","1","8"]
class Solution:
    def solve(self, n):
        if not n: return []
        ans=[]
        for half in product(mapping.keys(),repeat=n//2):
            half="".join(half)
            if half and half[0] == "0": continue
            rh=""
            for c in half:
                rh = mapping[c] + rh
            if n&1: # add middles
                for mid in mids:
                    ans.append(half+mid+rh)
            else:
                ans.append(half+rh)
        return ans
        

Word Formation
-------------
If letters has every letter in the word (or more), it means that the intersection of the letters in word and letters will contain all the letters in word. 

I sorted by length so the first correct result we meet is the largest one, but it is more efficient to keep a max result.
-------------
from collections import Counter
class Solution:
    def solve(self, words, letters):
        cl=Counter(letters)
        for w in sorted(words, key=len, reverse=True):
            cw=Counter(w)
            if cw&cl==cw:
                return len(w)
        return 0

Minimum Adjacent Swaps to Palindrome
-------------
The first step is to check for validity - we can make a palindrome only if there is at most 1 character of odd frequency (the center).

Then we can apply a two pointer solution, one pointer pointing the leftmost character and one pointer pointing the rightmost character. If they are equal, we can continue on to the next sub problem by incrementing/decrementing both pointers.

If they are unequal, we check the cost of swapping the rightmost occurence of the left character completely to the right versus swapping the leftmost occurence of the right character to the left - we can greedily take the minimum cost. I have no idea how to prove this, so this exercice will be left as an exercice to the reader :) (let me know if you know how to prove it).

One important case to handle as well is when we meet the character of odd frequency, the center. When we meet it, we are forced to swap it because it cannot stay on the edge of the current substring.
-------------
from collections import Counter
class Solution:
    def solve(self, s):
        cnt=Counter(s)
        if sum(1 for freq in cnt.values() if freq&1)>1: return -1
        s=list(s)
        i=0
        j=len(s)-1
        def swap(start,end, step=1):
            first=s[start]
            for i in range(start,end,step):
                s[i] = s[i+step]
            s[end]=first
        ans=0
        while i<j:
            leftchar = s[i]
            rightchar = s[j]
            if leftchar != rightchar:
                rightmostleft = "".join(s).rindex(leftchar,i,j)
                leftmostright = s.index(rightchar,i,j)
                # checking for middle
                if cnt[leftchar]&1:
                    swap(leftmostright, i, -1)
                    ans+=leftmostright-i
                elif cnt[rightchar]&1:
                    swap(rightmostleft, j)
                    ans+=j-rightmostleft
                elif leftmostright < (len(s)-1-rightmostleft):
                    swap(leftmostright, i, -1)
                    ans+=leftmostright-i
                else:
                    swap(rightmostleft, j)
                    ans+=j-rightmostleft
            i+=1
            j-=1
        return ans

Remove Last Duplicate Entries
-------------
We count frequencies, and store all duplicates in a set by checking if frequency is > 1.

Then we iterate over nums, decreasing frequency of each number met, and when we reach the last instance of a duplicate number we ignore it.
-------------
from collections import Counter
class Solution:
    def solve(self, nums):
        c=Counter(nums)
        dup={x for x,f in c.items() if f>1}
        ans=[]
        for n in nums:
            if c[n]!=1 or n not in dup:
                ans.append(n)
                c[n]-=1
        return ans
Interval Duration
-------------
Literally add every value in the intervals in a set and count unique values.

Don't use this in production.
-------------
class Solution:
    def solve(self, intervals):
        s=set()
        for i,j in intervals:
            s.update(range(i,j+1))
        return len(s)

Shipping and Receiving
-------------
Inspired by alex's answer.
We compute the shortest path starting from every node __once__, then query the correct dictionary.
-------------
from functools import lru_cache
class Solution:
    def solve(self, ports, shipments):
        @lru_cache(None)
        def bfs(source):
            dist = {source: 0}
            queue = [source]
            for node in queue:
                for nei in ports[node]:
                    if nei not in dist:
                        dist[nei] = dist[node] + 1
                        queue.append(nei)
            return dist
        
        return sum(bfs(u).get(v, 0) for u, v in shipments)


Number of Palindromic Substrings
-------------
We try every possible center for our palindromes, expanding as much as possible. This works because the center part of a palindrome is a palindrome as well:

tacocat
acoca
coc
o
-------------
class Solution:
    def solve(self, s):
        def expand(i,j):
            ans=0
            while i>=0 and j<len(s) and s[i] == s[j]:
                i-=1
                j+=1
                ans+=1
            return ans
        return sum(expand(i,i)+expand(i,i+1) for i in range(len(s)))
Make Palindrome by Adding a Suffix
-------------
We try to find the largest palindrome that touches the right border, and the answer consist in the number of characters not included in that palindrome.
-------------
class Solution:
    def solve(self, s):
        ans=len(s)-1
        for i in range(len(s)):
            for j,k in ((i,i), (i,i+1)):
                l,r= expand(j,k,s)
                if r==len(s)-1:
                    ans=min(ans,len(s)-(r-l+1))
        return ans
        
def expand(i,j,s):
    while i>=0 and j<len(s) and s[i]==s[j]:
        i-=1
        j+=1
    i+=1
    j-=1
    return i,j
Dividing Station
-------------
One key insight to this problem is that, if a number is divisible by the largest number of a subset, it will be divisible by all the other numbers, because the largest number is a multiple of them.

Following that logic, we can sort the numbers and for each number I check if it divisible by the largest number of the current subset and if so, I add it. If it doesn't belong to any existing subset, I create a new subset.
-------------
class Solution:
    def solve(self, nums):
        nums.sort()
        ss=[[nums.pop(0)]]
        for n in nums:
            found=False
            for subset in ss:
                if n%subset[-1]==0:
                    subset.append(n)
                    found=True
            if not found:
                ss.append([n])
        return max(len(x) for x in ss)
            
    
Knight Remains
-------------
Since each move is equiprobable, the probability of staying in the board for a cell is the sum of the probabilities of the cells you can jump to divided by 8. We recurse to a depth of k.
-------------
from functools import lru_cache
moves=[(1,2),(1,-2), (-1,2),(-1,-2),(2,1),(2,-1),(-2,1),(-2,-1)]
class Solution:
    def solve(self, n, x, y, k):
        @lru_cache(None)
        def dfs(x,y,k):
            if x<0 or y <0 or x>=n or y>=n: return 0
            if k == 0: return 1
            return sum(dfs(x+dx, y+dy,k-1)/8 for dx,dy in moves)
        return int(dfs(x,y,k)*100)

Flight Itinerary Sequel
-------------
This problem consists in finding an Eulerian path (or circuit) in a graph. An Eulerian path is a path that passes through all the edges of a graph, and in this problem the edges are represented by flights.

The algorithm implemented here is Hierholzer's algorithm, the fastest algorithm that i know of. It runs in O(|E|), |E| being the number of edges. This video explains it in detail: https://www.youtube.com/watch?v=8MpoO2zA2l4.


-------------
from collections import defaultdict
class Solution:
    def solve(self, flights):
        ins = defaultdict(int)
        outs = defaultdict(int)
        adj_list = defaultdict(list)
        for s,e in flights:
            adj_list[s].append(e)
            outs[s]+=1
            ins[e]+=1
        for l in adj_list.values():
            l.sort()
        start=None
        end=None
        for airport in adj_list.keys():
            if outs[airport]-ins[airport] == 1:
                if start:  return
                start = airport
            elif outs[airport]-ins[airport] == -1:
                if end: return
                end = airport
            elif outs[airport]-ins[airport] != 0: return
        start=start if start else min(adj_list.keys())
        ans=[]
        def dfs(airport):
            while outs[airport]:
                nxt=len(adj_list[airport])-outs[airport]
                outs[airport]-=1
                dfs(adj_list[airport][nxt])
            ans.append(airport)
        dfs(start)
        return ans[::-1]
Equal Piles
-------------
The only way to all numbers to be the same is to all become equal to the smallest number.

For any number to become equal to the smallest number, they must first go through every number in between.

So we can sum the number of unique numbers in between the current number and the smallest to get the answer.
-------------
class Solution:
    def solve(self, nums):
        d={x:i for i,x in enumerate(sorted(set(nums)))}
        return sum(d[x] for x in nums)
        
Intervals Intersecting at Point
-------------
We count the number of intervals that include the time given as a parameter.
-------------
class Solution:
    def solve(self, intervals, time):
        return sum(1 for s,e in intervals if s<=time<=e)

Majority Vote
-------------
Simple way of solving this, using the most_common function of Python's Counter.
-------------
from collections import Counter
class Solution:
    def solve(self, nums):
        c=Counter(nums)
        n,freq = c.most_common(1)[0]
        if freq>len(nums)//2:
            return n
        return -1

Longest Zero Sublist Sum
-------------
We can find intervals where the sum is zero by the running sum is equal for two indexes, which means the difference in sum between the two points is zero.
-------------
class Solution:
    def solve(self, nums):
        d={0:-1}
        ans=0
        sm=0
        for i,n in enumerate(nums):
            sm+=n
            if sm in d:
                ans=max(ans, i-d[sm])
            else:
                d[sm] = i
        return ans
            

Number of Unique Character Substrings
-------------
For a substring of repeating characters e.g. "aaaa", where n = len(s), we will have:
1 substring of length 4 : "aaaa"
2 substrings of length 3: "aaa", "aaa"
3 substrings of length 2: "aa", "aa", "aa"
4 substrings of length 1: "a", "a", "a", "a"

So the number of substrings will be 1+2+...+n, which is a known arithmetic sequence that equals n*(n+1)/2.
-------------
from itertools import groupby
class Solution:
    def solve(self, s):
        ans=0
        for _, grp in groupby(s):
            n=len(list(grp))
            ans+=n*(n+1)//2
        return ans

Sudoku Solver
-------------
Simple backtracking solution, with the only optimization being storing taken values in a set, to be able to get all possible values without iterating through the grid.
-------------
class Solution:
    def solve(self, matrix):
        # taken values for each set
        rows=[set() for _ in range(9)]
        cols=[set() for _ in range(9)]
        regions=[set() for _ in range(9)]
        
        # all possible values for a set
        nums=set(range(1,10))
        
        # populate sets
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if matrix[i][j]:
                    rows[i].add(matrix[i][j])
                    cols[j].add(matrix[i][j])
                    regions[get_region(i,j)].add(matrix[i][j])
                    
        # backtrack on all possible values
        def backtrack(i=0,j=0):
            if i>=9: return True
            if matrix[i][j]:
                i,j = it(i,j)
                return backtrack(i,j)
            possibilities = nums - rows[i] - cols[j] - regions[get_region(i,j)]
            for num in possibilities:
                rows[i].add(num)
                cols[j].add(num)
                regions[get_region(i,j)].add(num)
                matrix[i][j]=num
                if backtrack(*it(i,j)): return True
                matrix[i][j]=0
                rows[i].remove(num)
                cols[j].remove(num)
                regions[get_region(i,j)].remove(num)
            return False
            
        if backtrack(): return matrix
        return False
        
# helper functions
def it(i,j):
    j+=1
    i+=j//9
    j%=9
    return i,j
    
def get_region(i,j):
    return i-i%3 + j//3

Weird Clock
-------------
We build a set of valid characters from the initial string, then increment one minute until we reach a time with characters subset of the initial string.
-------------
from datetime import datetime, timedelta
class Solution:
    def solve(self, s):
        time=datetime.strptime(s,"%H:%M")
        digits=set(s)
        while True:
            time+=timedelta(minutes=1)
            s2=time.strftime("%H:%M")
            if len(set(s2)-digits)==0: return s2
Roomba Sequel
-------------
No tricks here, just implement what is told. Here is a clean example, with a dictionary of functions to apply the moves.
-------------
move={
    "NORTH": lambda x,y: (x,y+1),
    "EAST": lambda x,y: (x+1,y),
    "SOUTH": lambda x,y: (x,y-1),
    "WEST": lambda x,y: (x-1,y)
}
class Solution:
    def solve(self, moves, tx, ty):
        x,y=0,0
        seen={(x,y)}
        for m in moves:
            while (x,y) in seen:
                x,y = move[m](x,y)
            seen.add((x,y))
        return (x,y)==(tx,ty)
Hanging Banners
-------------
We sort the intervals by their end. When iterating, we keep an upper bound which is the current max end time. If the start of the next interval is before the bound, we have an intersection so we do not need to count an extra time, otherwise this interval is independent and we have to add it to the answer.
-------------
class Solution:
    def solve(self, intervals):
        intervals.sort(key=lambda i: i[1])
        last = float('-inf')
        ans = 0
        for s, e in intervals:
            if s <= last:
                continue
            last = e
            ans += 1
        return ans
Remove Duplicates in Linked List
-------------
We keep track of seen values with a set. We look ahead of the current node to see if its value is in the set, if so we erase it by modifying the pointer to the next value.

Important to note, we don't continue iterating if we found a duplicate. Imagine:
1->1->1-> 2
If we remove the second one, we don't jump to the third one, we redo the check before jumping to the next node.
-------------
# class LLNode:
#     def __init__(self, val, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def solve(self, node):
        head=node
        seen=set()
        while node.next:
            seen.add(node.val)
            if node.next.val in seen:
                node.next = node.next.next
            else:
                node=node.next
        return head
Buy and Sell K Stocks
-------------
Top-down DP solution: 

For each index in the array, we have two possibilites: either buy/sell the stock (depending if we are holding one currently) or do nothing. So we take the max of the two options.
-------------
from functools import lru_cache
class Solution:
    def solve(self, prices, k):
        @lru_cache(None)
        def dp(i, k, bought):
            if i==len(prices) or k==0: return 0
            if bought:
                return max(dp(i+1, k-1, False)+prices[i], dp(i+1,k,bought))
            else:
                return max(dp(i+1,k,True)-prices[i], dp(i+1,k,bought))
        return dp(0,k,False)

Second Place
-------------
We can iterate over leaves using a generator, storing the nodes according to their depths. Then, we sorted nodes based on depth and take the second largest depth.
-------------
from collections import defaultdict
class Solution:
    def solve(self, root):
        depths=defaultdict(list)
        for n,d in it(root):
            depths[d].append(n.val)
        a=sorted(depths.items(),reverse=True)
        return a[1][0]
        
def it(node,depth=0):
    if not node.left and not node.right: yield node,depth
    if node.left: yield from it(node.left, depth+1)
    if node.right: yield from it(node.right, depth+1)

Rain Catcher Sequel
-------------
This approach to the problem is going in reverse - instead of starting from a square a finding the path of least height to the edge, we start from the edge and use a min heap to continually process the lowest square of ground.

When we process the square of least height, we add its neighbors to the heap. We also check if their height is smaller than the current square (the smallest possible neighbor to the square). If so, we add the difference to the answer. The new value in the heap will be the max of the two values.

Since the amount of water of a square is constrained by the path with the smallest maximal height - processing the paths starting from the edge with the smallest maximal height first will converge towards a correct answer.

Basically, this is dijkstra's algorithm with multiple starting points (the edge), and the key being the maximum along the path.
-------------
from heapq import heappop, heapify, heappush
class Solution:
    def solve(self, matrix):
        if len(matrix)<3 or len(matrix[0])<3: return 0
        def get_neighbors(i,j):
            for di,dj in [(1,0), (-1,0), (0,1), (0,-1)]:
                ni,nj = i+di, j+dj
                if ni>=0 and nj>=0 and ni < len(matrix) and nj<len(matrix[0]):
                    yield (ni,nj)
                    
        hp=[]
        seen=set()
        ans=0
        for i in range(len(matrix)):
            key = (matrix[i][0], i, 0)
            hp.append(key)
            key = (matrix[i][-1], i, len(matrix[0])-1)
            hp.append(key)
            seen.add((i,0))
            seen.add((i,len(matrix[0])-1))
        for j in range(1,len(matrix[0])-1):
            key = (matrix[0][j], 0, j)
            hp.append(key)
            key = (matrix[-1][j], len(matrix)-1, j)
            hp.append(key)
            seen.add((0,j))
            seen.add((len(matrix)-1,j))
        heapify(hp)
        while hp:
            cur_level, i, j = heappop(hp)
            for ni,nj in get_neighbors(i,j):
                if (ni,nj) in seen: continue
                seen.add((ni,nj))
                nei_level = matrix[ni][nj]
                if nei_level < cur_level:
                    ans += cur_level - nei_level
                heappush(hp,(max(nei_level, cur_level), ni, nj))
        return ans
                

List Calculator
-------------
Don't waste your time, let python eval shit for you

-------------
class Solution:
    def solve(self, nums, op, val):
        op = "//" if op == "/" else op
        return list(map(lambda x: eval(op.join([str(x),str(val)])),nums))
        
Multiple Parentheses
-------------
We keep track of nesting levels using a dictionary. Each time we meet a "(", we increase the current nesting level (cnt), each time we meet a ")" we decrease it. If we ever go under a nesting level e.g. "())", the reference to the nesting level cannot be used anymore because it is invalid. We return the longest distance between two positions with the same nesting level, where we never go under the nesting level in between those positions.
-------------
class Solution:
    def solve(self, s):
        ans=0
        left={}
        cnt=0
        for i,c in enumerate(s):
            if cnt not in left: left[cnt]=i
            d = 1 if c == "(" else -1
            if d == -1 and cnt in left: 
                del left[cnt]
            cnt+=d
            cnt=max(cnt,0)
            if cnt in left:  ans=max(ans, i-left[cnt]+1)
        return ans

TV Shows
-------------
It's like taking the k largest numbers out of an array, but first you need to combine the numbers belonging to the same title. We can do so using a dictionary.
-------------
from collections import defaultdict
class Solution:
    def solve(self, shows, durations, k):
        d=defaultdict(int)
        for t,dur in zip(shows, durations):
            d[t] += dur
        a = sorted(d.values(), reverse=True)
        return sum(a[:k])

Social Distancing 2
-------------
Dynamic programming isn't that hard, right guys? (right?). 
-------------
class Solution:
    def solve(self, matrix):
        dp=[[0]*len(matrix[0]) for _ in matrix]
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if matrix[i][j]: continue
                if i>0: dp[i][j] = dp[i-1][j]+1
                if j>0: dp[i][j] = min(dp[i][j], dp[i][j-1]+1)
                if i>0 and j>0: dp[i][j] = min(dp[i][j], dp[i-1][j-1]+1)
                if i>0 and j<len(matrix[0])-1: dp[i][j] = min(dp[i][j], dp[i-1][j+1]+1)
            for j in range(len(matrix[0])-1,-1,-1):
                if matrix[i][j]: continue
                if j<len(matrix[0])-1: dp[i][j] = min(dp[i][j], dp[i][j+1]+1)
                
        for i in range(len(matrix)-1,-1,-1):
            for j in range(len(matrix[0])-1,-1,-1):
                if matrix[i][j]: continue
                if i<len(matrix)-1: dp[i][j] = min(dp[i][j], dp[i+1][j]+1)
                if j<len(matrix[0])-1: dp[i][j] = min(dp[i][j], dp[i][j+1]+1)
                if i<len(matrix)-1 and j<len(matrix[0])-1: dp[i][j] = min(dp[i][j], dp[i+1][j+1]+1)
                if j>0 and i<len(matrix)-1: dp[i][j] = min(dp[i][j], dp[i+1][j-1]+1)
            for j in range(len(matrix[0])):
                if matrix[i][j]: continue
                if j>0: dp[i][j] = min(dp[i][j], dp[i][j-1]+1)
        return max(v for r in dp for v in r)
                

Convert to Full Binary Tree
-------------
We check the cases where only one child is not None, and we return its value if so.

Note that we do the recursion at the start of the function, so that we proceed in a bottom-up fashion. 
-------------
# class Tree:
#     def __init__(self, val, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def solve(self, root):
        if not root: return
        root.left=self.solve(root.left)
        root.right=self.solve(root.right)
        if root.left is not None and root.right is None:
            return root.left
        if root.left is None and root.right is not None:
            return root.right
        return root

Bunnyhopping
-------------
Here, we have a dp array where we store the minimum cost to reach the end from any position. We start from the end, where we know that the minimal cost to reach the end is the cost of the end itself.

Then, we iterate backwards to the start. For each position, we set its value to the sum of the cost of reaching the position + the minimum cost in the window of size k following the position.

To keep track of the minimum cost in range k following the position, we use a monotone increasing queue, that keeps the values ordered and within range using some magic. First, it removes all indexes out of range, computes the current value, then appends the current value to the queue, removing all values greater or equal than it from the end.
-------------
class Solution:
    def solve(self, nums, k):
        dp = [0 for _ in nums]
        dp[-1] = nums[-1]
        q=[len(nums)-1]
        for i in range(len(nums)-2,-1,-1):
            while q and i+k < q[0]:
                q.pop(0)
            dp[i] = dp[q[0]]+nums[i]
            while q and dp[q[-1]] >= dp[i]:
                q.pop()
            q.append(i)
        return dp[0]

String Addition
-------------
Less lazy solution: zip string from the right, adding the remainder of the sum modulo 10 to the answer, and saving the carry.
-------------
from itertools import zip_longest
class Solution:
    def solve(self, a, b):
        carry=0
        ans=[]
        for x,y in zip_longest(a[::-1],b[::-1],fillvalue=0):
            carry,a=divmod(int(x)+int(y)+carry,10)
            ans.append(a)
        if carry: ans.append(carry)
        return "".join(map(str,ans[::-1]))

Compress String
-------------
Groupby will group consecutive equal elements, so we can join the key from that group.
-------------
from itertools import groupby
class Solution:
    def solve(self, s):
        return "".join(k for k,_ in groupby(s))
Condo Developers
-------------
We compute the max for each rows and each columns. zip(*matrix) is the matrix transposed, where each row are the columns.

Since we can't change the maximum of any row or column, we must be equal to the minimum of the max of the row and the max of the column we are modifying.
-------------
class Solution:
    def solve(self, matrix):
        rows=[max(r) for r in matrix]
        cols=[max(c) for c in zip(*matrix)]
        ans=[[0 for _ in r] for r in matrix]
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                ans[i][j] = min(rows[i], cols[j])
        return ans

Ugly Number
-------------
We remove all 2,3,5 factors from the number. If there is anything left, it means there are greater prime factors left to be explored.
-------------
class Solution:
    def solve(self, n):
        for d in (2,3,5):
            while n%d==0:n=n//d
        return n==1
        

Largest and Smallest Difference
-------------
We sort the numbers because we want to check the values the closest together. Then we use a sliding window to check every possible sublist of length k.
-------------
class Solution:
    def solve(self, nums, k):
        nums.sort()
        mn=1e9
        for i in range(len(nums)-k+1):
            mn=min(mn, nums[i+k-1]-nums[i])
        return mn

Recursive Index
-------------
We apply A[k] while possible, incrementing the answer each time. We also delete the values behind our path, and if we encounter a deleted value we have detected a cycle.
-------------
class Solution:
    def solve(self, A, k):
        ans=0
        while k>=0 and k<len(A):
            if A[k] is None: return -1
            A[k],k=None,A[k]
            ans+=1
        return ans

K Maximum Non-Overlapping Sums
-------------
Top-down DP solution: for each index we have the choice between:
1. Starting a new sublist, adding our current number nums[i] to the total sum,
2. Continuing the current sublist, if we are in one (indicating by in_group),
3. Skipping the current number, ending the sublist if there was one.

Each time we start a sublist, we decrease the k remaining sublist left to create. When we finish the kth group - we return 0 to mark that we finished our sum, and if we reach an invalid state we return -infinity so it doesn't get picked when we maximize the results.
-------------
from functools import lru_cache
class Solution:
    def solve(self, nums, k):
        @lru_cache(None)
        def dp(i, k,in_group=False):
            if k == 0 and (not in_group or i >= len(nums)): return 0
            if i>=len(nums) or k<0: return -1e9
            return max(
                nums[i] + dp(i+1,k - (not in_group), True),
                nums[i] + dp(i+1,k - 1, True),
                dp(i+1, k, False)
            )
        return dp(0,k)
            
                

Making Change
-------------
In this specific situation, we can greedily pick the maximal number of the largest coin possible. This wouldn't work if we had coins of value (4,3,1) and n=6, for example.

This paper explains how to figure out when greedy is possible: https://graal.ens-lyon.fr/~abenoit/algo09/coins2.pdf
Warning: contains math
-------------
class Solution:
    def solve(self, n):
        ans=0
        for change in [25,10,5,1]:
           times,n = divmod(n,change)
           ans+=times
        return ans

Break String Into Words
-------------
We convert the words into a set to be able to do constant time lookup. 

Then we start from the start of the string, iterating over the string and storing the characters.
If we match a word in the set, we recursively retry accumulating from that point on and if it doesn't work we keep accumulating till the end of the word. If we exhaust our options there is no solution.

lru_cache ensures we don't recompute the outcomes for the same value of i, reducing this problem to O(n^2)
-------------
from functools import lru_cache
class Solution:
    def solve(self, words, s):
        words=set(words)
        @lru_cache(None)
        def rec(i=0):
            if i == len(s): return True
            acc=""
            for j in range(i, len(s)):
                acc+=s[j]
                if acc in words:
                    if rec(j+1): return True
            return False
        return rec()

Flipped Matrix
-------------
Our first goal is to set all first bits to one using row flips, since they are the most significant.

Then, we iterate column by column, counting the total number of ones and zeroes. If there is a greater number of zeroes, we flip the whole column.
-------------
class Solution:
    def solve(self, matrix):
        for r in matrix:
            if r[0]==0:
                for i in range(len(r)):
                    r[i] = -r[i]+1
        for j in range(1,len(matrix[0])):
            cnt=0
            for i in range(len(matrix)):
                cnt+=1 if matrix[i][j] else -1
            if cnt<0:
                for i in range(len(matrix)):
                    matrix[i][j] = -matrix[i][j]+1
        ans=0
        for r in matrix:
            a=0
            for v in r:
                a=2*a+v
            ans+=a
        return ans

String Addition
-------------
Lazy method: cast the strings to int, evaluate the addition and cast back to string.
-------------
class Solution:
    def solve(self, a, b):
        return str(int(a)+int(b))

Atbash Cipher
-------------
We create a dictionary mapping a to z, b to y, etc. And then we map the text to this dictionary.
-------------
from string import ascii_lowercase
class Solution:
    def solve(self, text):
        d = dict(zip(ascii_lowercase, ascii_lowercase[::-1]))
        return "".join(map(lambda c: d[c], text))

Common Words
-------------
We create a set of the lowercase words for each sentence, which will remove duplicates. Then Python offers the & operator on sets to do the intersection, which will keep the words that are in both sets. We return the length of the set that has the words shared by both sentences.

-------------
class Solution:
    def solve(self, s0, s1):
        a=set(x.lower() for x in s0.split())
        b=set(x.lower() for x in s1.split())
        return len(a&b)
        # Write your code here

Home Run
-------------
Groupby will group identical consecutive values together, so we can regroup the binary representation of the number and take the longest chain of ones.
-------------
from itertools import groupby
class Solution:
    def solve(self, n):
        mx=0
        for bit,group in groupby(bin(n)[2:]):
            if bit == "1":
                mx=max(mx,len(list(group)))
        return mx

Postfix Notation Evaluation
-------------
We traverse each element and push it onto a stack. Each time we meet an operator, we apply it to the last two elements pushed onto the stack. 
-------------
from operator import add,sub,mul
fn={
"+": add,
"-": sub,
"*": mul,
"/": lambda x,y: int(x/y)
}
class Solution:
    def solve(self, exp):
        stk=[]
        for x in exp:
            if x in fn:
                a,b=stk.pop(), stk.pop()
                stk.append(fn[x](b,a))
            else:
                stk.append(int(x))
        return stk[0]
    

Toeplitz Matrix
-------------
You don't need to iterate each diagonal individually. Checking equality with the direct diagonal neighbor is enough.

-------------
class Solution:
    def solve(self, matrix):
        for i in range(len(matrix)-1):
            for j in range(len(matrix[0])-1):
                if (matrix[i][j] != matrix[i+1][j+1]):
                    return False
        return True
        # Write your code here

Rectangular Overlap
-------------
Sexy one-liner solution. Iterate over each dimension individually, and check that the maximum of the start of the interval for each rectangle is less than the minimum of the ends.
-------------
class Solution:
    def solve(self, rect0, rect1):
        return all(max(s) < min(e) for s,e in zip(zip(rect0[:2],rect1[:2]), zip(rect0[2:],rect1[2:])))

Kth Last Node of a Linked List
-------------
Cheated solution, populate array with linked list values and take kth last element.
-------------
class Solution:
    def solve(self, node, k):
        A=[]
        while node:
            A.append(node.val)
            node=node.next
        return A[len(A)-1-k]

Stepping Numbers
-------------
DP solution: For each digit d, the number of ways of getting a number finishing by d of length n is the number of ways of getting a number of length n-1 finishing with d-1 or d+1.

So we start with the first digit, all ones except zero because our number cant have a leading 0. Then each n steps, we sum the diagonals, unless we are on the edge (0 or 9). 
-------------
MOD=10**9 + 7
class Solution:
    def solve(self, n):
        if n == 1: return 10
        digits = [1 for _ in range(10)]
        digits[0]=0
        for _ in range(n-1):
            next_d = [0 for _ in range(10)]
            for i,v in enumerate(digits):
                if i>0: next_d[i-1] += v
                if i < len(next_d) - 1: next_d[i+1] += v
            digits=next_d
        return sum(digits)%MOD

Parse Ternary Expression
-------------
We recursively try to solve until we reach a "true" or a "false". We find the left part by matching the first ?, and the right part by counting the number of ? and : until they balance out to 0.
-------------
class Solution:
    def solve(self, s):
        s=s.strip()
        if s=="true": return True
        elif s=="false": return False
        l=s.index("?")
        r=matching(l,s)
        if self.solve(s[:l]):
            return self.solve(s[l+1:r])
        else:
            return self.solve(s[r+1:])
    
def matching(i,s):
    cnt=0
    while i<len(s):
        if s[i]=="?": cnt+=1
        elif s[i]==":": cnt-=1
        if cnt==0: return i
        i+=1
K and -K
-------------
We build a set of negative values and a set of positive values.
We do the intersection between the two sets, which results in a set with value that belong both to the negative and the positive.

We return the max of this new set if is not empty, otherwise -1.
-------------
class Solution:
    def solve(self, nums):
        neg=set([-x for x in nums if x<=0])
        pos=set([x for x in nums if x>=0])
        common=neg&pos
        return max(common) if common else -1

Regular Expression Matching
-------------
Based on https://nickdrane.com/build-your-own-regex/

Recursive solution where we process one character from the pattern at the time, except if a star is involved.

To compare characters, we have the match_one function, that checks equality or if pattern is a "."
For stars, we have a match_star function, that tries to match all possibilities. If none match, we just ignore the star.
-------------
class Solution:
    def solve(self, pattern, s):
        return match(pattern,s)
        
def match(pattern, s):
    if not pattern and not s: return True
    if not pattern or not s: return False
    if len(pattern)>1 and pattern[1] == "*":
        return match_star(pattern, s)
    return match_one(pattern[0], s[0]) and match(pattern[1:], s[1:])
    
def match_star(pattern, text):
    i=0
    while i<len(text) and match_one(pattern[0], text[i]):
        if match(pattern[2:], text[i+1:]): return True
        i+=1
    return match(pattern[2:], text)
    
def match_one(pattern,text):
    return pattern == "." or pattern == text
        

Max Character Distinct Words
-------------
O(N^3) solution. (set intersection is linear)

We check each pair, check that the intersection of the sets of letters is empty, if so we save the max length.
-------------
class Solution:
    def solve(self, words):
        ltrs={w:set(w) for w in words}
        mx=0
        for i in range(len(words)):
            w1=words[i]
            for j in range(i+1, len(words)):
                w2=words[j]
                if len(ltrs[w1]&ltrs[w2])==0:
                    mx=max(mx, len(w1)+len(w2))
        return mx

Longest 1s After One Swap
-------------
We group identical consecutive values with groupby, find the longest chain of ones seperate by a single 0. If there are more than 2 chunks of ones, we don't have to reuse a one from the current groups so we can gain one extra one in our chain. 

Edge case to consider: all ones, all zeroes, only a single chain of ones.
(The tests don't check those, so the solution probably won't work in those cases).
-------------
from itertools import groupby
class Solution:
    def solve(self, s):
        groups=[(k,len(list(grp))) for k,grp in groupby(s)]
        mx=0  
        onegroups=[x[0] for x in groups].count("1")
        for i in range(1, len(groups)-1):
            k,l = groups[i]
            # matches single 0 surrounded by ones: ...1110111...
            if k == "0" and l==1 and groups[i-1][0]=="1" and groups[i+1][0]=="1":
                mx=max(mx, groups[i-1][1]+groups[i+1][1])
        return mx if onegroups<=2 else mx+1
Minimax Tree
-------------
Clean way to code it, hope you enjoy ;)                
-------------
fn=[min,max]
class Solution:
    def solve(self, node,you=True):
        if not node or not node.left and not node.right: return node
        node.left=self.solve(node.left,not you)
        node.right=self.solve(node.right,not you)
        node.val = fn[you](n.val for n in (node.left, node.right) if n)
        return node

Tree Coloring
-------------
Swapping adjacent nodes means we can reorder the nodes as we wish, so we just need to count the number of colors to see if they can fit in the ordered version of the tree.

If we would color the tree by hand, the colors would alternate between each level. So if we count the number of nodes of each odd level and each even level, it should equal the frequency of unique colors for it to be solvable.
-------------
from collections import defaultdict
class Solution:
    def solve(self, root):
        colors=defaultdict(int)
        prop=defaultdict(int)
        def dfs(node,flag=True):
            if not node:return
            colors[node.val]+=1
            prop[flag]+=1
            dfs(node.left, not flag)
            dfs(node.right, not flag)
        dfs(root)
        return set(colors.values()) == set(prop.values())
        

Non-Consecutive String
-------------
We can represent this problem as a tree, where every node represent a chosen character. The root of this tree will have three possibilities, then every node will have two options (to avoid repetition). 

We can avoid exploring subtrees unnecessarily by counting the number of nodes under it. Since we know the levels left for the tree (s) and how many children each node has (2**(s-1), because we double the number of nodes per level), we know that if the number of nodes in a subtree is less than k, we don't have to explore that subtree.

Similar to https://leetcode.com/problems/permutation-sequence/
-------------
class Solution:
    def solve(self, s, k,last=None):
        if s == 0: return ""
        for c in "012":
            if c == last: continue
            if k<2**(s-1):
                return c + self.solve(s-1, k, c)
            k -= 2**(s-1)
        return ""

Adjacent Swaps to Group Ones
-------------
For each zero in our string, we count the number of ones to the left of it and to the right of it. For any zero, we know that it will have to swap either to the left or to the right of all those ones, so ideally we will swap with the least amount out of the two options. So the answer will be the sum of the minimal number of ones each zero has to swap with.
-------------
class Solution:
    def solve(self, s):
        l,r=[0 for _ in s], [0 for _ in s]
        for i in range(1,len(s)): l[i]=l[i-1] + int(s[i-1]=="1")
        for i in range(len(s)-2,-1,-1): r[i]=r[i+1] + int(s[i+1]=="1")
        return sum(min(l[i], r[i]) for i in range(len(s)) if s[i]=="0")

Zipped String
-------------
We can use DP where i in the position in a, j the position in b and k the position in c.

Whenever a[i] == c[k], we can test dp(i+1,j,k+1)
Whenever b[j] == c[k], we can test dp(i, j+1, k+1)

If we reach the end of each string, we return True.
-------------
from functools import lru_cache
class Solution:
    def solve(self, a, b, c):
        @lru_cache(None)
        def dp(i=0,j=0,k=0):
            if i == len(a) and j == len(b) and k == len(c): return True
            if k == len(c): return False
            if i<len(a) and a[i] == c[k] and dp(i+1,j,k+1): return True
            if j<len(b) and b[j] == c[k] and dp(i, j+1, k+1): return True
            return False
        return dp()
A Strictly Increasing Linked List
-------------
We can look ahead to validate the constraints.           
-------------

class Solution:
    def solve(self, node):
        while node.next:
            if node.val>=node.next.val: return False
            node=node.next
        return True
Majority Vote
-------------
Constant space solution using Boyer-Moore majority vote algorithm: https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm
-------------
class Solution:
    def solve(self, nums):
        el=cnt=0
        for n in nums:
            if cnt==0: 
                el=n
                cnt=1
            elif n==el: cnt+=1
            else: cnt-=1
        cnt=sum(1 for n in nums if n==el)
        return el if cnt>(len(nums)//2) else -1
        
Binary Tree Width
-------------
For each level, we hold the leftmost and the rightmost values inside a dictionary.

To calculate the position,we need to count how many nodes are to the left of the current one:
``` 
        0
    0      1
  0  1   2   3
0 1 2 3 4 5 6 7
```
We can see a pattern emerge: each time we go left, the number of nodes to the left double, and if we go right we double as well, plus the left node.

In the end we return the largest interval.
-------------
from collections import defaultdict
class Solution:
    def solve(self, root):
        d=defaultdict(lambda: [1e9,0])
        def dfs(node, pos=0, depth=0):
            if not node: return
            d[depth][0]=min(d[depth][0],pos)
            d[depth][1]=max(d[depth][1],pos)
            dfs(node.left,2*pos,depth+1)
            dfs(node.right,2*pos+1,depth+1)
        dfs(root)
        mx=0
        for interval in d.values():
            l,r=interval
            mx=max(mx,r-l+1)
        return mx
            

Task Schedule
-------------
We greedily take the k+1 most common task, that represent the number of tasks you must do before being able to redo the first one.

When the number of unique tasks gets smaller than k, we continue adding k+1 time each iteration, but only subtract one from the available tasks.

We avoid waiting at the end by checking if there's anything left in the dictionary. If not, we just add the number of tasks left in the last iteration.
-------------
from collections import Counter
class Solution:
    def solve(self, nums, k):
        c=Counter(nums)
        ans=0
        while c:
            common=c.most_common(k+1)
            for task,freq in common:
                c[task]-=1
                if c[task]==0: del c[task]
            ans+=k+1 if c else len(common)
        return ans

Transpose of a Matrix
-------------
zip will pair corresponding elements together. For example:
```
[1,2,3]
[4,5,6]
```
will result in [(1,4), (2,5), (3,6)].  This is equivalent to a transposition.
```
[1,2,3]
[4,5,6]
[7,8,9]
=>
[(1,4,7),
 (2,5,8),
 (3,6,9)]
```
The star spreads the matrix and passes each list as an individual argument.
-------------
class Solution:
    def solve(self, matrix):
        return list(zip(*matrix))

Vowels and Consonants Sort
-------------
I create two sorted arrays, one with vowels, other with consonant, and return the joined result.
-------------
class Solution:
    def solve(self, s):
        return "".join(sorted(filter(vowels,s))+sorted(filter(consonant, s)))
def consonant(c):
    return not vowels(c)
def vowels(c):
    return c in "aeoui"
K Compare
-------------
We find the kth largest number in b. If a number if smaller than the kth largest number, it will be smaller than larger numbers as well. So we return the number of numbers in a that are smaller than that target number.
-------------
class Solution:
    def solve(self, a, b, k):
        if k>len(b): return 0
        if k==0: return len(a)
        b.sort()
        return sum(1 for n in a if n<b[-k])

Interval Union
-------------
Intersection happens when the end of the previous intervals overlaps the start of the current one. In that case, we can create a new interval comprising the minimum start and the max ending.
-------------
class Solution:
    def solve(self, intervals):
        intervals.sort()
        ans=[]
        for start,end in intervals:
            if ans and ans[-1][1]>=start:
                prev_start,prev_end = ans[-1]
                ans[-1]=(min(prev_start,start),max(prev_end,end))
            else:
                ans.append((start,end))
        return ans

Rain Catcher
-------------
The volume in each square is constrained by the minimum between the highest wall to the left of the current square and the highest wall to the right of the current square. 
-------------
class Solution:
    def solve(self, nums):
        l = [0 for _ in nums]
        r = [0 for _ in nums]
        for i in range(1,len(nums)):
            l[i] = max(l[i-1], nums[i-1])
        for i in range(len(nums)-2,-1,-1):
            r[i] =  max(r[i+1], nums[i+1])
        return sum(max(0, min(l[i],r[i])-nums[i]) for i in range(len(nums)))

Wildfire
-------------
Some people just want to see the world burn... https://www.youtube.com/watch?v=6l6vqPUM_FE
-------------
from collections import deque
class Solution:
    def solve(self, matrix):
        if not matrix: return 0
        q=deque([(i,j) for i,r in enumerate(matrix) for j,v in enumerate(r) if v==2])
        ans=0
        while q:
            burned=False
            for _ in range(len(q)):
                i,j=q.popleft()
                neighbors=[]
                for di,dj in [(-1,0),(1,0),(0,1),(0,-1)]:
                    ni,nj=i+di,j+dj
                    if ni>=0 and nj>=0 and ni<len(matrix) and nj<len(matrix[0]) and matrix[ni][nj]==1:
                        burned=True
                        matrix[ni][nj]=2
                        q.append((ni,nj))
            ans+=int(burned)
        return ans if all(all(x!=1 for x in r) for r in matrix) else -1
    
Count of Sublists with Same First and Last Values
-------------
One liner solution - view other write up for a more visual understanding.
-------------
from collections import Counter
class Solution:
    def solve(self, nums):
        return sum(n*(n+1)//2 for n in Counter(nums).values())
Job Scheduling to Maximize Profit
-------------
For each job i, we can either skip it, or take it and jump to the next job starting at e (we sort to be able to binary search for the next job).
-------------
from functools import lru_cache
from bisect import bisect_left
class Solution:
    def solve(self, intervals):
        intervals.sort()
        starts=[s for s,_,_ in intervals]
        @lru_cache(None)
        def dp(i):
            if i >= len(intervals): return 0
            s,e,p = intervals[i]
            ans = dp(i+1)
            j = bisect_left(starts,e)
            ans2 = dp(j) + p
            return ans if ans > ans2 else ans2
        return dp(0)

Rotate by 90 Degrees Counter-Clockwise
-------------
Why are you guys trying to hard, its just one line of code lmao
-------------
class Solution:
    def solve(self, matrix):
        return [list(x) for x in zip(*map(reversed,matrix))]

Longest Sign Alternating Subsequence
-------------
We only need to keep track of the longest subsequence finishing with a negative number or positive number. When the number we reach is negative, we always take the largest positive sequence, and when our number is positive, we take the largest negative sequence and add our number to it.
-------------
class Solution:
    def solve(self, nums):
        pos=neg=0
        for n in nums:
            if n<0:
                neg=pos+1
            else:
                pos=neg+1
        return max(pos,neg)
String Expansion
-------------
Each time we see a number, we add it to our coefficient variable.

Each time we see an opening parenthesis, we find the matching one and solve recursively.

Otherwise we just accumulate characters.
-------------
class Solution:
    def solve(self, s):
        ans=""
        coeff=""
        i=0
        while i<len(s):
            c=s[i]
            if c.isdigit():
                coeff+=c
            elif c == "(":
                j=matching(s,i)
                ans+=int(coeff) * self.solve(s[i+1:j])
                coeff=""
                i=j
            else:
                ans+=c
            i+=1
        return ans
                
def matching(s,i):
    cnt=0
    while True:
        if s[i] == "(": cnt+=1
        elif s[i] == ")": cnt-=1
        if cnt==0: return i
        i+=1
Sum of Three Numbers
-------------
To pick the first number, we iterate over the list.
To pick the next two, we put a pointer after i, and one to the end of the list. 

Because we sorted, we know every value after j will be greater than it, and every value before k will be smaller. So if our sum isn't big enough, we can increment j to get the next biggest value. If it's too big, we can decrement k.
-------------
class Solution:
    def solve(self, nums, k):
        nums.sort()
        for i in range(len(nums)-2):
            target=k-nums[i]
            j=i+1
            k=len(nums)-1
            while j<k:
                if nums[j]+nums[k] < target: j+=1
                elif nums[j]+nums[k] > target: k-=1
                else: return True
        return False

Lexicographic Swap
-------------
We want to minimize the values of the letters iterating from the left. If we could swap as much as we wanted, we would just sort the string but we can just swap once. So we can compare the string to its sorted equivalent and take the first value that doesn't match. We find its rightmost occurrence in the original string to minimize the value of the swap, and do the swap.
-------------
class Solution:
    def solve(self, s):
        ss=sorted(s)
        for i,(c1,c2) in enumerate(zip(s,ss)):
            if c1 != c2: break
        j=s.rindex(ss[i])
        s = list(s)
        s[i],s[j]=s[j],s[i]
        return "".join(s)
                

Changing Directions
-------------
We compute the slopes by doing nums[i+1] - nums[i].

Then, to check for changes from positive to negative slopes or the reverse, we can multiply adjacent slopes: only a positive and a negative will give a value less than zero, so then we can count the number of results lower than zero.
-------------
class Solution:
    def solve(self, nums):
        s = [nums[i+1]-nums[i] for i in range(len(nums)-1)]
        return sum(1 for i in range(len(s)-1) if s[i+1]*s[i]<0)
Level Order Traversal
-------------
Simplest form of breadth-first search. Use a double-ended queue to do popleft() in constant time.
-------------
from collections import deque
class Solution:
    def solve(self, root):
        ans=[]
        q=deque([root])
        while q:
            node = q.popleft()
            ans.append(node.val)
            if node.left: q.append(node.left)
            if node.right: q.append(node.right)
        return ans

    
Bomber Man Sequel
-------------
For each enemy in the matrix, we increment every reachable empty space in a separate matrix. We return the max value in the hit matrix.
-------------
class Solution:
    def solve(self, matrix):
        hit=[[0 for _ in matrix[0]] for _ in matrix]
        def mark(i,j):
            k=j+1
            while k<len(matrix[0]) and matrix[i][k] != 1:
                if matrix[i][k]==0: hit[i][k]+=1
                k+=1
            k=j-1
            while k>=0 and matrix[i][k] != 1:
                if matrix[i][k]==0: hit[i][k]+=1
                k-=1
            k=i+1
            while k<len(matrix) and matrix[k][j] != 1:
                if matrix[k][j]==0: hit[k][j]+=1
                k+=1
            k=i-1
            while k>=0 and matrix[k][j] != 1:
                if matrix[k][j]==0: hit[k][j]+=1
                k-=1
            
        for i,r in enumerate(matrix):
            for j,v in enumerate(r):
                if v == 2:
                    mark(i,j)
        return max(v for r in hit for v in r)

Coprime Suspects
-------------
BFS approach. I hate math so i just let computers try all possibilities for me.
-------------
from math import gcd
class Solution:
    def solve(self, a, b):
        def bfs(a,b):
            dist={(a,b):0}
            q=[(a,b)]
            while True:
                ca,cb = q.pop(0)
                cost=dist[(ca,cb)]
                if gcd(ca,cb) != 1: return cost
                for da, db in [(-1,0),(0,-1),(1,0),(0,1)]:
                    na,nb = ca+da, cb+db
                    if (na,nb) not in dist:
                        dist[(na,nb)]=cost+1
                        q.append((na,nb))
        return bfs(a,b)
Delete Even Leaves
-------------
Each node is responsible of telling its parent if it is deleting, by returning itself. We do the check after iteration, to respect the constraint that new leaves can be cut as well.
-------------
class Solution:
    def solve(self, root):
        def dfs(node):
            if not node: return None
            node.left=dfs(node.left)
            node.right=dfs(node.right)
            if not node.left and not node.right and not node.val&1: return None
            return node
        return dfs(root)

Only Child
-------------
Only child means there is either a left child or a right child but not both - otherwise known as a XOR. 
-------------
# class Tree:
#     def __init__(self, val, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def solve(self, root):
        if not root: return 0
        return self.solve(root.left) + self.solve(root.right) + ((root.left is None) ^ (root.right is None))

Sum of Right Leaves
-------------
Return the value if we meet the required conditions, otherwise we will eventually return 0. Use a boolean to check if we are a right child.
-------------
class Solution:
    def solve(self, root):
        def dfs(node, right=False):
            if not node: return 0
            if not node.left and not node.right and right: return node.val
            return dfs(node.left, False)+dfs(node.right, True)
        return dfs(root)

Unique Characters of Every Substring
-------------
We build a dictionary of lists that contains the indexes of each unique character. 

Let's say we have a string a__a__a where _ is any character except a. The number of times the middle a is adding 1 to the answer is the number of substrings where it is the only a. To count that, we can multiply the number of possible left bounds of substrings to the number of possible right bounds. The possible left bounds are all the values between the previous a and the current index, and the possible right bounds are all the values between the next a and the current index.
-------------
from collections import defaultdict
class Solution:
    def solve(self, s):
        pos=defaultdict(list)
        for i,c in enumerate(s):
            pos[c].append(i)
        ans=0
        for lst in pos.values():
            for i,idx in enumerate(lst):
                prev = -1 if i == 0 else lst[i-1]
                next = len(s) if i == len(lst)-1 else lst[i+1]
                left = next-idx
                right= idx-prev
                ans += left * right
        return ans % (10 ** 9 + 7)

Island Shape Perimeter
-------------
Every one in the matrix adds 4 to the perimeter, unless it has neighbors. In that case, it contributes 4 minus the number of neighbors.
-------------
class Solution:
    def solve(self, matrix):
        def get(i,j):
            if i<0 or j<0 or i>=len(matrix) or j>=len(matrix[0]):
                return 0
            return matrix[i][j]
        ans=0
        for i,r in enumerate(matrix):
            for j,v in enumerate(r):
                if v==1:
                    p=4
                    for ni,nj in ((i+1,j),(i-1,j),(i,j+1),(i,j-1)):
                        if get(ni,nj): p-=1
                    ans+=p
        return ans
                    

Making Change Trequel
-------------
1D dp solution: if we look at the 2D DP table, we can see that we basically copy the previous row by doing dp[i][j] = dp[i-1][j]. We can just reuse the same row to avoid copying.

Video explanation: https://www.youtube.com/watch?v=bV1CvGRu4cg&t=56s
-------------
class Solution:
    def solve(self, denominations, amount):
        dp=[0]*(amount+1)
        dp[0]=1
        for d in denominations:
            for i in range(1,len(dp)):
                if i-d >= 0: dp[i] += dp[i-d]
        return dp[-1] % (10 ** 9 + 7)

Count of Sublists with Same First and Last Values
-------------
We record the position for each number. The number of sublist where we pick n values is n*(n+1)/2, the arithmetic series 1+2+3+...+n

Ex:  say a number n is at 3 positions
we can pick 1-1, 1-2, 1-3, 2-2, 2-3, 3-3
which is 3+2+1, 3 positions starting at 1, 2 positions starting at 2, 1 starting at 3.
-------------
from collections import defaultdict
class Solution:
    def solve(self, nums):
        d=defaultdict(list)
        for i,n in enumerate(nums):
            d[n].append(i)
        return sum(len(l)*(len(l)+1)//2 for l in d.values())

Digital Lake
-------------
We can DP on the digits, where we iterate between every digit between 0 and the limit set by n for the current digit.

If we pick a digit smaller than the digit n[i], we can iterate over all 0-9 digits for the rest of the digits.

Then, when our digit is equal to our target d, we add it to the answer by the number of possibilities for the next digits.

One important edge case is when d=0, because we cannot considering leading zeroes e.g. 0001. For this, we check if we have at least one non-zero digit before the current digit to count zeroes.
-------------
from functools import lru_cache
class Solution:
    def solve(self, n, d):
        digits = [int(c) for c in str(n)]
        @lru_cache(None)
        def dp(i=0, free=False, leading=False):
            if i == len(digits):
                return 0,1
            ans=0
            possibilities=0
            for digit in range(10):
                if not free and digit > digits[i]: break
                subans, subpos = dp(i+1, free or digit < digits[i], leading | digit != 0)
                possibilities += subpos
                ans+=subans
                if (digit != 0 and digit == d) or (digit == d and leading):
                    ans += subpos
            return ans,possibilities
        return dp()[0]
                
                
Largest Equivalent Set of Pairs
-------------
We want to track the difference between the two sets - each number put into set B will be subtracted and each number put into set A will be added. If both sets are equal the difference will be 0. We then bubble up the sum reached.
-------------
from functools import lru_cache
class Solution:
    def solve(self, nums):
        @lru_cache(None)
        def dp(i, bal):
            if i==len(nums):
                return 0 if bal == 0 else -1e9
            return max(
                dp(i+1, bal),
                dp(i+1, bal+nums[i])+nums[i],
                dp(i+1, bal-nums[i])
                )
        return dp(0,0)

Largest Square Submatrix
-------------
Every square of side n is formed of three overlapping square of side (n-1). The subsquare's position are at i,j-1 i-1,j and i-1,j-1. The bigger square can only be as big as the smallest subsquare, plus one.
-------------
class Solution:
    def solve(self, matrix):
        a=0
        for i,r in enumerate(matrix):
            for j,v in enumerate(r):
                if v: a=max(a,1)
                if i==0 or j==0 or v==0: continue
                matrix[i][j]=min(matrix[i][j-1],matrix[i-1][j],matrix[i-1][j-1])+1
                a=max(a,matrix[i][j])
        return a**2
Flip and Invert Matrix
-------------
We can do both operations at the same time in a list comprehension, iterating over rows, and flipping the corresponding value from the end of the row.
-------------
class Solution:
    def solve(self, matrix):
        return [[1^row[~j] for j in range(len(row))] for row in matrix]

Median Minimization
-------------
2 lazy to do the math myself, let python do it for me lel
-------------
from statistics import median
class Solution:
    def solve(self, nums):
        nums.sort()
        return abs(median(nums[0::2])-median(nums[1::2]))

Chain of Blocks
-------------
Memoized solution: we store starts into a dictionary and then check max length path.
-------------
from collections import defaultdict
from functools import lru_cache
class Solution:
    def solve(self, blocks):
        if not blocks: return 0
        starts=defaultdict(list)
        for s,e in blocks:
            starts[s].append(e)
        @lru_cache(None)
        def dfs(cur):
            ans=1
            for end in starts[cur]:
                if end in starts:
                    ans=max(ans, dfs(end)+1)
            return ans
        return max(dfs(i) for i in starts.keys())
Multi Knapsack 
-------------
For each knapsack, we can either take it or not. So we try skipping and taking each value and take the maximal outcome.
-------------
from functools import lru_cache
class Solution:
    def solve(self, weights, values, capacity, count):
        @lru_cache(None)
        def dp(i, cap, cnt):
            if i>=len(weights) or cap<0 or cnt<0: return 0
            ans=dp(i+1, cap, cnt)
            if weights[i]<=cap and cnt>=1:
                ans=max(ans,dp(i+1,cap-weights[i],cnt-1)+values[i])
            return ans
        return dp(0,capacity,count)
IP Address Combinations
-------------
We can make a valid ip address generator by brute forcing all possible chunks of size 1,2 and 3. For each chunk, we check if there is no leading zeroes and if its in the [0,255] range. If so, we recursively try to build chunks from the remainder of the string. If we reach the end, it is a valid ip address.
-------------
class Solution:
    def solve(self, ip,cnt=4,prefix=""):
        addr = [a for a in addresses(ip)]
        return addr
        
    
def addresses(ip,cnt=4,prefix=[]):
    if ip=="" and cnt==0:  yield ".".join(prefix)
    if ip=="" or cnt==0: return
    for i in range(1,min(len(ip)+1, 4)):
        cur_prefix=ip[:i]
        if cur_prefix != "0" and cur_prefix != cur_prefix.lstrip("0"): continue
        if 0<=int(cur_prefix)<=255:
            prefix.append(cur_prefix)
            yield from addresses(ip[i:],cnt-1, prefix)
            prefix.pop()

Remove One Letter
-------------
Note: this solution doesn't check for order, but test cases pass so whatever.

Sexy one liner: The frequency of each character in s0 minus the frequency of each character in s1 should leave one character behind.
-------------
from collections import Counter
class Solution:
    def solve(self, s0, s1):
        return sum(v for v in (Counter(s0)-Counter(s1)).values()) == 1

Count Exact Sum
-------------
DP solution similar to knapsack.

We recursively iterate over each number, trying to pick each number for our subset if possible and skipping it.
We return one if we reach a subset of sum k, and we memoize everything.
-------------
from functools import lru_cache
MOD=(10**9)+7
class Solution:
    def solve(self, nums, k):
        @lru_cache(None)
        def dp(i,k):
            if k==0: return 1
            if i==len(nums): return 0
            ans=dp(i+1,k)
            if k>=nums[i]:
                ans+=dp(i+1,k-nums[i])
            return ans
        return dp(0,k)%MOD

Odd Palindrome
-------------
Every even-length palindrome is composed of two consecutive equal character at its center.
-------------
class Solution:
    def solve(self, s):
        for i in range(1,len(s)):
            if s[i] == s[i-1]:return False
        return True

Wolf of Wall Street
-------------
Buy high sell low.

The best time to buy a stock was at its lowest point in the past, and the best moment to sell is at the maximum point from the lowest.
-------------
class Solution:
    def solve(self, prices):
        mx=0
        m=prices[0]
        for p in prices:
            m=min(m,p)
            mx = max(mx, p-m)
        return mx

Palindrome Count
-------------
We cut the string and half, and compute the number of possibilities by raising the number of letters to the number of characters used in the first half of the palindrome.
-------------
class Solution:
    def solve(self, s, k):
        d,m = divmod(k,2)
        l=len(s)
        return l**d * l**m

Reverse Sublists to Convert to Target
-------------
If we can reverse any sublist, it means we can swap any two elements. For example: [1,2,3,4,5]. If we want to swap 1 and 5, we must reverse the whole array, then reverse the array between 1 and 5:
[5,4,3,2,1]
[5,2,3,4,1]
If we can swap any arbitrary elements, we can reorder the array as we wish, so the only constraint for this problem is that nums and target contain the same values.

Seen here: https://leetcode.com/contest/biweekly-contest-27/problems/make-two-arrays-equal-by-reversing-sub-arrays/
-------------
from collections import Counter
class Solution:
    def solve(self, nums, target):
        return Counter(nums) == Counter(target)

Decimal Number
-------------
Inspired by alex's solution.

This solution is based on grade-school division. The way we detect recurring digits is if we have a cycle while doing our division. Let's take 1/3 for example:

1 | 3
Since our numerator (1) is smaller than our denominator (3), we shift the decimal place and multiply the numerator by 10.
10 | 3 = 0.
3 can fix 3 times in ten, so we subtract 3*3 from 10 and add 3 to the decimal places:
1 | 3 = 0.3
1 has already been seen, so we are in a cycle. Everything between the last occurrence of 1 and now will be repeated forever.
-------------
class Solution:
    def solve(self, numerator, denominator):
        sign = '-' if numerator * denominator < 0 else ''
        numerator = abs(numerator)
        denominator = abs(denominator)
        intpart, r = divmod(numerator, denominator)
        ans = [sign + str(intpart)]
        if r: ans.append(".")
        
        seen = {}
        t = 0
        while r and r not in seen:
            seen[r] = t
            t += 1
            n, r = divmod(10 * r, denominator)
            ans.append(str(n))
        
        if r:
            ans.insert(seen[r] + 2, '(')
            ans.append(')')
        return "".join(ans)
FizzBuzz
-------------
Sexy one-liner. You can multiply by booleans! Isn't that nice. Pull this bad boy out during an interview and you'll make them soak.
-------------
class Solution:
    def solve(self, n):
        return [("Fizz"*(n%3==0)+"Buzz"*(n%5==0)) or str(n) for n in range(1,n+1)]

Make Lists Same with Sublist Sum Operations
-------------
Two pointers solution: We start with a pointer pointing at the start of each list, and a running sum for each list. We add the current numbers to the running sum, and increment the pointer with the smallest running sum, in the hopes that it will grow to become the running sum of the second list. When each running sum are equal, we have found an element in our resulting array. We can increment our answer and reset our running sums to zero.

To check if a solution is possible, we must reach the end of both lists with no running sum.
-------------
class Solution:
    def solve(self, l0, l1):
        ans=i=j=a=b=0
        while True:
            if a != 0 and a == b:
                ans += 1
                a=b=0
            elif a < b:
                if i>=len(l0): break
                a += l0[i]
                i +=1
            else:
                if j>=len(l1): break
                b += l1[j]
                j += 1
        return ans if i == len(l0) and j == len(l1) and a == 0 and b == 0 else -1

Sentence Reversal
-------------
We can retrieve the sentence by joining the list. Then to reverse the words, we split on spaces and reverse the resulting list. The we join the words with spaces and return the result as a list of characters.
-------------
class Solution:
    def solve(self, words):
        return list(" ".join("".join(words).split(" ")[::-1]))

Country Roads
-------------
Graph coloring solution. If we visualize our tree as rows of cities, we alternate between rows of town and rows of cities starting from the root. We chose the max out of the two possibilities.
-------------
from collections import defaultdict
class Solution:
    def solve(self, source, dest, population):
        adj_list=defaultdict(list)
        color_cities=defaultdict(list)
        nodes=set()
        ends=set()
        for s,e in zip(source,dest):
            nodes.add(s)
            nodes.add(e)
            ends.add(e)
            adj_list[s].append(e)
        color=False
        start = (nodes-ends).pop()
        q=[start]
        while q:
            for _ in range(len(q)):
                cur=q.pop(0)
                color_cities[color].append(population[cur])
                for n in adj_list[cur]: q.append(n)
            color^=True
        return max(sum(x) for x in color_cities.values())

Longest Rotated Palindromic Substring
-------------
How I Learned to Stop Worrying and Love the Palindrome.

Here's a cool trick to check for substring palindromes.

Let's take a palindrome s="racecar".

and two pointers, i=4 and j=4, that denote the middle of a potential palindrome.

As long as the two characters s[i] and s[j] are equal, we can decrement i and increment j to find the length. Example:

palindrome\_len = 0

"r a c e c a r"

i .......^.........

j........^.........

s[i] == s[j] ? yes: palindrome += 1 if i == j else 2

palindrome\_len = 1

"r a c e c a r"

i .....^..........

j ...........^....

s[i] == s[j] ? yes: palindrome += 1 if i == j else 2

palindrome\_len = 3

"r a c e c a r"

i ..^..............

j ..............^..

s[i] == s[j] ? yes: palindrome += 1 if i == j else 2

palindrome\_len = 5

"r a c e c a r"

i ^.................

j .................^

s[i] == s[j] ? yes: palindrome += 1 if i == j else 2

palindrome\_len = 7

We stop iterating if the palindrome length matches the string length.

This also works for even-length palindromes, such as s="anna".

Instead of having i and j start at the same value, we increment j.

"a n n a"

i ..^......

j......^...

And repeat the same process as before.

Now, we can iterate over every index in s, and look for the longest palindrome at that position. To deal with the rotation, we just have to use modulos each time we increment and decrement the pointers. In Python, -1 % len(s) will give len(s)-1, so we will loop around the string automatically.

​

​

​

​

-------------
class Solution:
    def solve(self, s):
        maxx=0
        for i in range(len(s)):
            maxx=max(maxx, longest(s, i, i))
            maxx=max(maxx, longest(s, i, i+1))
            print(i, maxx)
        return maxx
        # Write your code here
    
def longest(s, i, j):
    l=0
    i = i%len(s)
    j = j%len(s)
    while(s[i]==s[j] and l<=len(s)):
        if l==0 and i == j:
            l+=1
        elif i != j:
            l+=2
        else:
            break
        i-=1
        j+=1
        i = i%len(s)
        j = j%len(s)
    return min(l, len(s))

Scrum Journeyman
-------------
We can treat start of intervals and end of intervals separately, using a new "events" array. Each time a new interval starts, we increment a running count variable, and each time an interval ends, we decrement it. 

Each time the running count changes, we commit the state to the answer array. Be careful to eliminate empty ranges, and ranges when the running count is zero.
-------------
class Solution:
    def solve(self, intervals, jobs):
        ev=[]
        for s,e in intervals:
            ev.append((s,1))
            ev.append((e,-1))
        ev.sort()
        cnt=0
        last=-1
        ans=[]
        for t, inc in ev:
            if t != last and cnt != 0:
                ans.append([last,t,cnt])
            cnt+=inc
            last=t
        return ans
Stacks
-------------
Since we can pop off any number of elements we want, we check all prefix sums as they all are possible solutions. Because the stack contains only positive values, we will never see the same sum twice for one stack.
-------------
from collections import defaultdict
class Solution:
    def solve(self, stacks):
        sums=defaultdict(int)
        for stk in stacks:
            s=0
            for n in stk:
                s+=n
                sums[s]+=1
        ans=0
        for s,f in sums.items():
            if f >= len(stacks) and s > ans:
                ans=s
        return ans
Knights' Attack
-------------
We iterate over the matrix and for each knight we find, we try all his possible moves and check if a knight is there.
-------------
class Solution:
    def solve(self, matrix):
        moves=[(2,1),(2,-1),(-2,1),(-2,-1),(1,2),(1,-2),(-1,2),(-1,-2)]
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if matrix[i][j]:
                    for di,dj in moves:
                        if check(i+di,j+dj,matrix): return True
        return False
                
def check(i,j,matrix):
    return i>=0 and j>=0 and i<len(matrix) and j<len(matrix[0]) and matrix[i][j]

Guess the Root
-------------
Lazy method: compute the square root and round it off.
-------------
class Solution:
    def solve(self, n):
        return int(n**0.5)

Reverse a Linked List
-------------
Small code, big pp. Is it possible to make this a one-liner though?
-------------
class Solution:
    def solve(self, node):
        prev=None
        while node:
            node.next,prev,node=prev,node,node.next
        return prev
Selling Products
-------------
We try to remove the least frequent ID's, as long as its possible.
-------------
from collections import Counter
class Solution:
    def solve(self, items, n):
        c=Counter(items)
        ans=len(c)
        freq=sorted(c.values())
        i=0
        while i<len(freq):
            if freq[i]<=n:
                n-=freq[i]
                ans-=1
            else:
                return ans
            i+=1
        return 0
            

Minimum Set of Pairs
-------------
O(n^2 log (n^2)) solution. 

First, we generate a list with all the distances between all possible pairs: n^2 time.
Then, We sort the list based on the distance between the numbers in the pairs. We want to minimize the difference of the difference because we are free to choose the sign of the difference: 

imagine in the original list [2,3,4,6,9] we have the pair of numbers (2,4) with difference of two. If we want the difference to be -2, we put 4 in the first pair, and 2 in the second pair. If we want the difference to be 2, we put 4 in the first pair and 2 in the second pair.

So when we have our two pairs (2,4) and (3,6) with respective difference of 2 and 3, since we can rearrange the sign as we want we can get the minimal difference of sum by doing abs(diff1-diff2). 
abs(2-3) = abs(-1) = 1.

In the code, we sort the differences so we only have to check the neighboring pairs that don't contain the same numbers, and since the list is ordered we know which value is bigger, so we don't have to use abs.
-------------
class Solution:
    def solve(self, nums):
        dists=[]
        for i in range(len(nums)-1):
            for j in range(i+1, len(nums)):
                dists.append((abs(nums[i]-nums[j]), i, j))
        dists.sort()
        ans=1e9
        for i in range(len(dists)-1):
            dist,i1,i2 = dists[i]
            j=i+1
            dist2,i3,i4 = dists[j]
            while j<len(dists) and len({i1,i2,i3,i4})!=4:
                dist2,i3,i4 = dists[j]
                j+=1
            if len({i1,i2,i3,i4})==4:
                ans=min(ans, dist2-dist)
        return ans
The Auditor
-------------
This is a classic base conversion problem in disguise. We must go from base 26 to base 10, where every character's value is its position in the alphabet, 1-indexed.

Note: using a dictionary to store the characters values would be more efficient than index()
-------------
from string import ascii_uppercase as alphabet
class Solution:
    def solve(self, s):
        ans=0
        for c in s:
            ans*=26
            ans+=alphabet.index(c)+1
        return ans
K Prefix
-------------
We can simply compute the prefix sum for each i, then iterate from the right until we find a position that satisfies the constraint.
-------------
class Solution:
    def solve(self, nums, k):
        for i in range(1,len(nums)):
            nums[i]+=nums[i-1]
        for i in range(len(nums)-1,-1,-1):
            if nums[i]<=k: return i
        return -1
0-1 Knapsack
-------------
For each knapsack, we can either take it or not, so we try both possibilities recursively as long as we have sufficient capacity. We memoize using @lru_cache.
-------------
from functools import lru_cache
class Solution:
    def solve(self, weights, values, capacity):
        @lru_cache(None)
        def dp(i, cap):
            if i>=len(weights): return 0
            ans=dp(i+1, cap)
            if cap>=weights[i]:
                ans=max(ans, dp(i+1, cap-weights[i])+values[i])
            return ans
        return dp(0,capacity)

List Consecutive Split
-------------
The logic is to compute the frequency of each number, then take the smallest k numbers, check if they are continuously increasing and remove them.
-------------
from collections import Counter
class Solution:
    def solve(self, nums, k):
        c=Counter(nums)
        while len(c)>=k:
            sub=sorted(c.keys())[:k]
            if any(sub[i]!=sub[i-1]+1 for i in range(1,len(sub))): return False
            for key in sub:
                c[key]-=1
                if not c[key]: del c[key]
        return len(c)==0

Mindboggling
-------------
We build a Trie datastructure with the dictionary and explore the matrix using DFS from each position. 

Read more about tries here: https://en.wikipedia.org/wiki/Trie
-------------
from itertools import product
class Trie:
    def __init__(self):
        self.children={}
        self.end=False
    def add_word(self,w):
        self.add_trie_nodes(w,w)
    def add_trie_nodes(self,w,full_word):
        if w=="": 
            self.end=True
            self.word=full_word
        elif w[0] in self.children:
            self.children[w[0]].add_trie_nodes(w[1:],full_word)
        else:
            t=Trie()
            t.add_trie_nodes(w[1:],full_word)
            self.children[w[0]] = t
    def contains(self, character):
        return character in self.children
    def get_child(self, character):
        return self.children[character]
    
    def is_end(self):
        return self.end
        
    def get_word(self):
        return self.word
        
def in_bounds(i,j,matrix):
    return i>=0 and j>=0 and i<len(matrix) and j<len(matrix[0])
    
class Solution:
    def solve(self, matrix, words):
        trie=Trie()
        for word in words:
            trie.add_word(word)
        directions = list(product(range(-1,2),repeat=2))
        found={}
        seen=[[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]
        def dfs(position,trie_node):
            if trie_node.is_end():
                found[trie_node.get_word()]=True
                return
            i,j=position
            for di,dj in directions:
                ni,nj = i+di, j+dj
                if in_bounds(ni,nj,matrix) and not seen[ni][nj] and trie_node.contains(matrix[ni][nj]):
                    seen[ni][nj]=True
                    dfs((ni,nj), trie_node.get_child(matrix[ni][nj]))
                    seen[ni][nj]=False
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                dfs((i,j), trie)
        return sum(found.values())
                    
                

Number of Quadruplets That Sum Target
-------------
We compute all sums between a&b and c&d and count their frequencies. For each sum in s1, we add its frequency times the frequency of its complement in s2, which gives the number of possible unique combinations.
-------------
from collections import Counter
class Solution:
    def solve(self, a, b, c, d, target):
        s1 = Counter([a[i]+b[j] for i in range(len(a)) for j in range(len(b))])
        s2 = Counter([c[i]+d[j] for i in range(len(c)) for j in range(len(d))])
        ans=0
        for k,v in s1.items():
            ans+=v*s2[target-k]
        return ans

Largest Rectangle Submatrix
-------------
https://www.geeksforgeeks.org/maximum-size-rectangle-binary-sub-matrix-1s/
-------------
class Solution:
    def solve(self, matrix):
        dp=[0 for _ in matrix[0]]
        ans=0
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if matrix[i][j]:
                    dp[j]+=matrix[i][j]
                else:
                    dp[j]=0
            ans=max(ans,max_area_histogram(dp))
        return ans
            
def max_area_histogram(histogram): 
      
    # This function calulates maximum  
    # rectangular area under given  
    # histogram with n bars 
  
    # Create an empty stack. The stack  
    # holds indexes of histogram[] list.  
    # The bars stored in the stack are 
    # always in increasing order of  
    # their heights. 
    stack = list() 
  
    max_area = 0 # Initialize max area 
  
    # Run through all bars of 
    # given histogram 
    index = 0
    while index < len(histogram): 
          
        # If this bar is higher  
        # than the bar on top 
        # stack, push it to stack 
  
        if (not stack) or (histogram[stack[-1]] <= histogram[index]): 
            stack.append(index) 
            index += 1
  
        # If this bar is lower than top of stack, 
        # then calculate area of rectangle with  
        # stack top as the smallest (or minimum 
        # height) bar.'i' is 'right index' for  
        # the top and element before top in stack 
        # is 'left index' 
        else: 
            # pop the top 
            top_of_stack = stack.pop() 
  
            # Calculate the area with  
            # histogram[top_of_stack] stack 
            # as smallest bar 
            area = (histogram[top_of_stack] * 
                   ((index - stack[-1] - 1)  
                   if stack else index)) 
  
            # update max area, if needed 
            max_area = max(max_area, area) 
  
    # Now pop the remaining bars from  
    # stack and calculate area with  
    # every popped bar as the smallest bar 
    while stack: 
          
        # pop the top 
        top_of_stack = stack.pop() 
  
        # Calculate the area with  
        # histogram[top_of_stack]  
        # stack as smallest bar 
        area = (histogram[top_of_stack] * 
              ((index - stack[-1] - 1)  
                if stack else index)) 
  
        # update max area, if needed 
        max_area = max(max_area, area) 
  
    # Return maximum area under  
    # the given histogram 
    return max_area 
List Partitioning
-------------
Count the frequency of each color, then rebuild it in order. Apparently faster than rayz solution?
-------------
from collections import Counter
class Solution:
    def solve(self, s):
        c=Counter(s)
        return ["red"]*c["red"]+["green"]*c["green"]+["blue"]*c["blue"]
Linked List Delete Last Occurrence of Value
-------------
A neat single-pass trick to solving this problem is keeping a reference to the last seen target. We start before the list and always check if the next value is the target, so we have a reference to the previous node. This way, we can easily update the references.
-------------
class Solution:
    def solve(self, node, target):
        front=cur=LLNode(None,node)
        ref=None
        while cur.next:
            if cur.next.val==target: ref=cur
            cur=cur.next
        if ref:
            ref.next=ref.next.next
        return front.next

Left Side View of a Tree
-------------
We apply BFS to the tree, in such a way that we iterate one level at a time using for _ in range(len(q)). We take the first node in each level for our answer.
-------------
from collections import deque
class Solution:
    def solve(self, root):
        
        q=deque([root])
        ans=[]
        while q:
            first=True
            for _ in range(len(q)):
                cur=q.popleft()
                if first:
                    ans.append(cur.val)
                for c in (cur.left, cur.right):
                    if c: q.append(c)
                first=False
        return ans

Level Order Binary Tree to Linked List
-------------
Breadth-first search, adding a node at the end of the linked list at each iteration.
-------------
class Solution:
    def solve(self, root):
        q=[root]
        head=prev=None
        while q:
            node=q.pop(0)
            if node.left:q.append(node.left)
            if node.right:q.append(node.right)
            if not head:
                head=prev=LLNode(node.val)
            else:
                prev.next=LLNode(node.val)
                prev=prev.next
        return head

Swappable Trees
-------------
We try swapping at each node, and checking for equality at each equivalent node.

Not sure about time complexity, but I think it's O(n) because for each node we have two possible sub-states, either keep trees the same or flip the trees. It has to be under O(n^2), because that is the number of possible unique inputs to the function.

Edit: seems to be O(n^2)
-------------
# class Tree:
#     def __init__(self, val, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def solve(self, root0, root1):
        def dfs(root0, root1):
            if not root0 and not root1: return True
            if not root0 or not root1: return False
            return root0.val == root1.val and (
                (dfs(root0.left, root1.left) and dfs(root0.right, root1.right)) or
                (dfs(root0.left, root1.right) and dfs(root0.right, root1.left)) 
                )
        return dfs(root0, root1)

Palindrome Linked List
-------------
Cheated solution, fill an array with linked list values and check whether it is symmetric.
-------------
# class LLNode:
#     def __init__(self, val, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def solve(self, node):
        a=[*it(node)]
        return a == a[::-1]

def it(node):
    while node:
        yield node.val
        node=node.next
Eliminate It!    
-------------
No need to learn how to code when Python can do it for you!
-------------
class Solution:
    def solve(self, s):
        return s.replace("xz","").replace("y","")

Anagram Partitioning
-------------
Recursive solution: each time the frequency of the characters in each character is matched, we do a recursive call and check if the rest of the string is solvable.
-------------
from collections import Counter
class Solution:
    def solve(self, a, b):
        def bt(i=0):
            if i == len(a): return True, []
            cnta = Counter()
            cntb = Counter()
            for j in range(i, len(a)):
                cnta[a[j]]+=1
                cntb[b[j]]+=1
                if cnta == cntb:
                    solved, indexes = bt(j+1)
                    if solved:
                        indexes.append(i)
                        return solved, indexes
            return False, []
        solved, rev_idx = bt()
        if not solved: return []
        else: return rev_idx[::-1]

Back to Front Linked List
-------------
Lazy solution: stick everything in a list, then pop back, pop front, ... and reorder shit.
-------------
class Solution:
    def solve(self, node):
        a=[*it(node)]
        ans=[]
        while a:
            ans.append(a.pop())
            if a: ans.append(a.pop(0))
        for i in range(len(ans)-1):
            ans[i].next=ans[i+1]
        ans[-1].next=None
        return ans[0]
        

def it(node):
    while node:
        yield node
        node=node.next
Square One
-------------
Similar idea to the Largest square medium problem, with the additional constraint that all values are equal. 

We create the additionnal dp matrix that stores the largest square with bottom-right corner at [i][j]. Then we iterate over the matrix: if a value is equal to its top, top-left and left values, then we can make a larger square with the smallest of its neighboring values.
-------------
class Solution:
    def solve(self, matrix):
        dp =[[1]* len(matrix[0]) for _ in matrix]
        for i in range(1,len(matrix)):
            for j in range(1,len(matrix[0])):
                if matrix[i][j] == matrix[i-1][j-1] == matrix[i][j-1] == matrix[i-1][j]:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1
        return max(v for r in dp for v in r)

S-Expression Evaluation
-------------
Recursive approach:

- Each time we a parentheses, we find the matching one and evaluate recursively.
- Otherwise, we group our three values into an array and evaluate them.
-------------
class Solution:
    def solve(self, s):
        ans=[""]
        i=1
        while i<len(s)-1:
            if s[i]=="(":
                j=matching_paren(s,i)
                ans[-1]+=str(self.solve(s[i:j+1]))
                i=j
            elif s[i]==" " and ans[-1]:
                ans.append("")
            else:
                ans[-1]+=s[i]
            i+=1
        return compute(*ans)
        
def compute(op,x,y):
    d={
        "+": lambda x,y: x+y,
        "-": lambda x,y: x-y,
        "*": lambda x,y: x*y,
        "/": lambda x,y: int(x/y)
    }
    print(op,x,y)
    return d[op](int(x),int(y))
    
def matching_paren(s, i):
    paren=0
    for j in range(i, len(s)):
        if s[j]=="(":paren+=1
        elif s[j]==")":paren-=1
        if not paren: return j
Triangle Triplets
-------------
To make a valid triangle ABC, A+B>C, A+C>B and B+C>A. If we sort the numbers, we can look at the two smaller numbers to see if they are bigger than the third, since the other constraint will be true if so.

We pick two numbers, and then we look for the highest value for which A+B>C. We can do a binary search for this position using our two picked values.

Then, Since we know all the values for C in range (j,k) are valid, we can add k-j-1 to our answer.
-------------
from bisect import bisect_left
class Solution:
    def solve(self, nums):
        nums.sort()
        cnt=0
        for i in range(len(nums)):
            x=nums[i]
            k=i+1
            for j in range(i+1, len(nums)):
                y=nums[j]
                k=bisect_left(nums, x+y, k)
                cnt+=k-j-1
        return cnt%(10**9+7)
Repeated Deletion
-------------
https://www.youtube.com/watch?v=3zUUtf7gOe8

Add characters onto a stack. Each time you encounter a new character, check whether the top of the stack contains duplicates, if so, pop them.
-------------
class Solution:
    def solve(self, s):
        stk=[]
        for c in s:
            if len(stk) > 1 and c != stk[-1] and stk[-1] == stk[-2]:
                top=stk[-1]
                while stk and top == stk[-1]: stk.pop()
            stk.append(c)
        # check for trailing duplicates
        if len(stk) > 1 and stk[-1] == stk[-2]:
            top=stk[-1]
            while stk and top == stk[-1]: stk.pop()
        return "".join(stk)

Labyrinthian Possibilities
-------------
1D dp solution: we build upon the 2D DP solution described in my other editorial.

We noticed that for each row in our DP matrix, we copied the precedent row, so instead we can just re-iterate on the same row to avoid copying.
-------------
class Solution:
    def solve(self, matrix):
        if matrix[0][0]: return 0
        matrix[-1][-1]=0
        dp = [0]*len(matrix[0])
        dp[0]=1 
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if matrix[i][j]: dp[j] = 0
                elif j>0: dp[j] += dp[j-1]
        return dp[-1] % (10 ** 9 + 7)

Switcheroo
-------------
For a switch to be one, it must have a odd number of divisor, because each divisor will flip the switch. 

The only numbers with this property are perfect squares, because normally each number has an even number of divisors, making up pairs. take 14 (not a perfect square):
1 14
2 7
But when we have a perfect square (ex: 16):
1 16
2 8
4 4
One divisor will be repeated within a pair, making the total number of unique divisors odd. 

Taking the square root of a number will give the number of perfect squares, because every square in range [1,n] is in range [1, n^2] and we reverse this mapping.
-------------
from math import sqrt
class Solution:
    def solve(self, n):
        return int(sqrt(n))

Triangle Stairs
-------------
"*"*i to get the correct numbers of stars,
rjust(n, " ") to always fill right with spaces!
-------------
class Solution:
    def solve(self, n):
        return "\n".join([("*"*i).rjust(n," ") for i in range(1,n+1)])

Stack Sequence
-------------
We can replay the pushes, and whenever we can pop the value at the start of pops, we do it cause why not.

-------------
class Solution:
    def solve(self, pushes, pops):
        s=[]
        for p in pushes:
            s.append(p)
            while s and pops and s[-1] == pops[0]:
                s.pop()
                pops.pop(0)
        return s == pops == []

Repeated Deletion
-------------
EDIT: invalid because we never check for trailing duplicates, view other solution.

https://www.youtube.com/watch?v=3zUUtf7gOe8

Add characters onto a stack. Each time you encounter a new character, check whether the top of the stack contains duplicates, if so, pop them.
-------------
class Solution:
    def solve(self, s):
        stk=[]
        for c in s:
            if len(stk) > 1 and c != stk[-1] and stk[-1] == stk[-2]:
                top=stk[-1]
                while stk and top == stk[-1]: stk.pop()
            stk.append(c)
        return "".join(stk)

Adjacent Differences
-------------
Take any increasing array: [1,4,8,9,10]
If we remove any number not touching the sides (e.g. 8), the max interval can only increase (4->8 will become 4->9), because the new difference between the hole made by removing the number will add together. So the strategy to minimize difference is removing numbers from the edges. We can use dp for this, as shown above. 
-------------
from functools import lru_cache
class Solution:
    def solve(self, nums, k):
        diffs=[nums[i]-nums[i-1] for i in range(1,len(nums))]
        @lru_cache(None)
        def dp(i,j,cnt):
            if cnt==0: 
                m=0
                for k in range(i,j+1):
                    m=max(m,diffs[k])
                return m
            return min(dp(i+1,j,cnt-1), dp(i,j-1,cnt-1))
        return dp(0,len(diffs)-1, k)
        

N Lexicographic Integers
-------------
Cast to string, sort and re-cast to int does the trick.
-------------
class Solution:
    def solve(self, n):
        return list(map(int, sorted(map(str, range(1,n+1)))))

Diminishing Words
-------------
We try all possible letter removal, and if its valid we repeat the process on the sub-word.
-------------
class Solution:
    def solve(self, words, s):
        mx=0
        def dfs(w,depth=1):
            if w not in words: return
            nonlocal mx
            mx=max(mx,depth)
            for i in range(len(w)):
                w2 = w[:i] + w[i+1:]
                dfs(w2,depth+1)
        dfs(s)
        return mx

Moo
-------------
I hold a dictionary for every cow and their direction. Then i iterate over each cow, and try to move it to the next position. If two cows reserve the same position, none goes there. When no change is made, we return the result.
-------------
class Solution:
    def solve(self, cows):
        cow_line=[c for c in cows]
        cow_directions={}
        for i,c in enumerate(cow_line):
            if c=="L" or c=="R":
                cow_directions[i] = cow_to_direction(c)
        done=False
        while not done:
            done=True
            mark=[None for _ in cow_line]
            for pos,dir in cow_directions.items():
                if 0<=pos+dir<len(cow_line) and cow_line[pos+dir]=="@":
                    if mark[pos+dir] is None:
                        mark[pos+dir] = cow_line[pos]
                    else:
                        mark[pos+dir] = None
            cow_directions={}
            for i,cow in enumerate(mark):
                if cow is not None:
                    done=False
                    cow_line[i]=cow
                    cow_directions[i]= cow_to_direction(cow)
        return "".join(cow_line)

def cow_to_direction(cow):
    return 1 if cow=="R" else -1
Unique Subsequences Equal to Target
-------------
DP O(n^2) solution: we can either skip the current character in s, or if it matches the current character in t, advance both pointers.
-------------
from functools import lru_cache
MOD = 10**9 + 7
class Solution:
    def solve(self, s, t):
        if not t: return 0
        @lru_cache(None)
        def dp(i,j):
            if j == len(t): return 1
            if i == len(s): return 0
            ans=dp(i+1,j)
            if s[i] == t[j]:
                ans += dp(i+1, j+1)
            return ans % MOD
        return dp(0,0)

Interleaved Linked List
-------------
We can pair corresponding elements in l0 and l1 using zip_longest and a generator, consecutively adding the current node to the new linked list.
-------------
from itertools import zip_longest
class Solution:
    def solve(self, l0, l1):
        head=prev=LLNode(0)
        for x,y in zip_longest(it(l0),it(l1), fillvalue=None):
            for z in (x,y):
                if z: prev.next = LLNode(z.val); prev=prev.next
        return head.next
def it(node):
    while node:
        yield node
        node=node.next

Dominos
-------------
Similar to Tromino Theory;

 We have two different states with different recurrence relations: The state where the board is flat and the state where there is a hole on the sides. We count the different states we can reach from each of them. 

Explained in this video I made: https://www.youtube.com/watch?v=ccbPq-CqVRk
-------------
from functools import lru_cache
MOD = (10**9) + 7
class Solution:
    def solve(self, n):
        @lru_cache(None)
        def f(n):
            if n == 0: return 1
            if n < 0: return 0
            return (f(n-2) + 2*f(n-2) + 2*g(n-2)) % MOD
            
        @lru_cache(None)
        def g(n):
            if n <= 0: return 0
            return (f(n-2) + g(n-2)) % MOD
            
        return f(n)

Sort String by Flipping
-------------
For every position in the string, compute the number of x's to the right and the number of y's to the left. The sum of those values equals the cost of changing the string to respect the constraint for the given split position. We return the minimum cost by checking every split position.
-------------
class Solution:
    def solve(self, s):
        xr=[0 for _ in range(len(s)+1)]
        yl=[0 for _ in range(len(s)+1)]
        for i in range(len(s)-2, -2, -1):
            xr[i]=xr[i+1]+(s[i+1]=="x")
        for i in range(1,len(s)+1):
            yl[i]=yl[i-1]+(s[i-1]=="y")
        return min(x+y for x,y in zip(xr,yl))
N Lexicographic Integers
-------------
We can use the key attribute of sort to specify a function to map the value before comparing.
-------------
class Solution:
    def solve(self, n):
        return sorted(range(1,n+1), key=str)

Top View of a Tree
-------------
We perform a regular BFS, with the position of the nodes relative to root. We overwrite the value if it hasn't been seen to emulate the projection.

-------------
class Solution:
    def solve(self, root):
        top={}
        q=[(root, 0)]
        while q:
            node,pos = q.pop(0)
            if pos not in top: top[pos]=node.val
            if node.left: q.append((node.left,pos-1))
            if node.right: q.append((node.right,pos+1))
        return [v for _,v in sorted(top.items())]

Longest Even Value Path
-------------
For each node, we check the longest path that comes from a child, goes through the node and back down to the other child. When returning to the parent node, we must pick the longest path coming from the child nodes.
-------------
# class Tree:
#     def __init__(self, val, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def solve(self, root):
        mx=0
        def dfs(node):
            nonlocal mx
            if not node: return 0
            l=dfs(node.left)
            r=dfs(node.right)
            if node.val%2==1: return 0
            mx=max(mx, 1+l+r)
            return max(l,r)+1
        dfs(root)
        return mx
            
    
Repeating String
-------------
For all cycle lengths, we check if the start of the string repeated equals the original string. We only need to check up to the half of the string, and only if the cycle length is a divisor of the length of the string.
-------------
from itertools import cycle
class Solution:
    def solve(self, s):
        return any(all(x==y for x,y in zip(s,cycle(s[:i]))) for i in range(1,1+len(s)//2) if len(s)%i==0)
            

Run-Length Decoding
-------------
Group digits together and letters together.

Each time you see a group of letters, repeat it by the last number seen.
-------------
from itertools import groupby
class Solution:
    def solve(self, s):
        cnt=1
        ans=""
        for k,grp in groupby(s, key=lambda x: x.isdigit()):
            if k:
                cnt = int("".join(grp))
            else:
                ans+=cnt*str("".join(grp))
                cnt=1
        return ans
        

Robinhood
-------------
While the dollar amount is less than the target, apply one interest rate, then the other.
-------------
class Solution:
    def solve(self, n, e, o, t):
        ans=0
        while n<t:
            n*=1+(e/100)
            ans+=1
            if n<t:
                n*=1+(o/100)
                ans+=1
        return ans

24
-------------
Fix for my last solution, where there was a bug where the root of the expression tree for a part of the array was lost.
-------------
import operator
from itertools import permutations, product
OPERATORS=["+","-","*","/"]
class Solution:
    def solve(self, nums):
        for operators in product(OPERATORS,repeat=3):
            for order in permutations(range(3)):
                if compute(operators,order,nums): return True
        return False

class Node:
    fn={
        "+": operator.add,
        "-": operator.sub,
        "*": operator.mul,
        "/": operator.floordiv
    }
    def __init__(self, value, left=None, right=None):
        self.value=value
        self.left=left
        self.right=right
        self.parent=None
    def compute(self):
        if not self.left and not self.right:
            return self.value
        return Node.fn[self.value](self.left.compute(),self.right.compute())
    def __repr__(self):
        return self.__str__()
    def __str__(self):
        if not self.left and not self.right: return str(self.value)
        return f"({self.value} {str(self.left)} {str(self.right)})"

def compute(operators,order,nums):
    nums=[Node(n) for n in nums]
    for idx in order:
        op = operators[idx]
        left = nums[idx]
        while left.parent: left = left.parent
        right = nums[idx+1]
        while right.parent: right = right.parent
        node=Node(op, left, right)
        left.parent, right.parent = node,node
    try:
        return node.compute() == 24
    except ZeroDivisionError:
        return False
Symmetric Blocks
-------------
This was a tough one. Even though I managed to solve it during the contest, I felt like I needed to come back to it with a fresh perspective to come up with a logical solution. Here it finally is (hopefully)!

The hardest part of this problem is understanding the relation between the height, and the position (j) of the block. We can take a simple example to illustrate it:
```
X
X
XXX
```
Here, We can see that the height of the first block is equal to the length of the array. Let's try another example:
```
XX
XX
XXXX
XXXX
```
We can see again that the first block is the same length as the array. But let's look at how the height of the rightmost element affects the symmetry. Since the last block is of height 2, it tells us that the first 2 elements must be of height n, the length of the array. 

We can generalize this for any position in the array. For any position j, its height tells us how many elements counting from the left must be at least of height j. If we iterate from the right, we can assert that those elements must be exactly height j, because every j to the left will be smaller.
-------------
class Solution:
    def solve(self, nums):
        i=0
        j=len(nums)-1
        while i<=j:
            h=nums[j]
            while i<h:
                if nums[i] != j+1: return False
                i+=1
            j -= 1
        return True

K and -K
-------------
We can use set comprehensions to build the set directly as well.
-------------
class Solution:
    def solve(self, nums):
        x={n for n in nums if n>=0}
        y={-n for n in nums if n<=0}
        z=x&y
        return max(z) if z else -1

Reverse a Linked List
-------------
The trick is to keep a reference to the previous node and set it as next after saving the next node in the list.
-------------
class Solution:
    def solve(self, node):
        prev=None
        cur=node
        while cur:
            next=cur.next
            cur.next=prev
            prev=cur
            cur=next
        return prev

Minimum Distance of Two Words in a Sentence
-------------
Remember when you last saw word0 and word1, and check the distance with the last word0 when you see word1 and word1 when you see word0.
-------------
from itertools import groupby
class Solution:
    def solve(self, text, word0, word1):
        if word0 not in text or word1 not in text: return -1
        last0=-1e9
        last1=-1e9
        ans=1e9
        for i,w in enumerate(text.split()):
            if w == word0:
                ans=min(ans, i-last1-1)
                last0=i
            if w == word1:
                ans=min(ans, i-last0-1)
                last1=i
        return ans
Last to Toggle Wins
-------------
Best explained here: https://cp-algorithms.com/game_theory/sprague-grundy-nim.html
-------------
from functools import lru_cache
from itertools import groupby
class Solution:
    def solve(self, nums):
        ans=0
        for k,grp in groupby(nums):
            if k: ans^=grundy(len(list(grp)))
        return ans>0
        
def mex(seen):
    a=0
    while a in seen:
        a+=1
    return a

@lru_cache(None)
def grundy(n):
    if n <= 1: return 0
    seen={grundy(n-2-i)^grundy(i) for i in range(n-1)}
    return mex(seen)


Divisible Numbers
-------------
Combination of the inclusion-exclusion principle and binary search:

We binary search between zero and n * max(a,b,c) for our answer. For each tested number, we count the number of multiples of that number using the inclusion-exclusion principle. If we don't have enough multiples for the current number, we search the higher bound otherwise we try to search lower.
-------------
from math import gcd
class Solution:
    def solve(self, n, a, b, c):
        def lcm(a,b):
            return a*b // gcd(a,b)
            
        def count_multiples(x):
            ans = x // a + x // b + x // c
            ans -= x // lcm(a,b) + x // lcm(b,c) + x // lcm(a,c)
            ans += x // lcm(a,lcm(b,c))
            return ans
        lo = 0
        hi = n*max(a,b,c)
        ans=-1
        while lo <= hi:
            mid = (lo+hi)//2
            cnt = count_multiples(mid)
            print(mid,cnt)
            if cnt >= n:
                ans=mid
                hi = mid-1
            else:
                lo = mid+1
        return ans
Foo Bar Qaz Qux
-------------
LOOK AT OTHER EDITORIAL
Three cases:
If there is only one unique color: return the length of the string.

Now it gets funky. If the frequency are all even or all odd, the answer will be two. Here's my best explanation as to why. At each iteration, we remove one from the frequency of two colors, and add one to the frequency of the last color. Here's an illustration, where R and G are combined.
```
R G B
4 4 4
3 3 5
```
If we remove one from an even number, it will give an odd number. The same holds when we add one to an even number. So if all frequencies are even on one iteration, they will all be odd on the next, and then even, etc. Following this line of logic, the frequency of each color will eventually be (1,1,1):
```
R G B
4 4 4
3 3 5
2 2 6
1 1 7
2 0 6
1 1 5
2 0 4
1 1 3
2 0 2
1 1 1
```
And when that happens, we are fucked. Because when we combine two of those colors, we will be left with two identical colors.

Here's what happens if they are not all even or odd:
```
R G B
3 4 4
2 3 5
1 2 6
0 1 7
1 0 6
0 1 5
1 0 4
0 1 3
1 0 2
0 1 1
```
In the final state, one or two numbers will be even, and the rest one will be odd. If two ones are left, we can make our last one, otherwise we already reached our end state.
-------------
from collections import Counter
class Solution:
    def solve(self, quxes):
        cnt=Counter(quxes)
        if len(cnt)==1: return len(quxes)
        if len({x%2 for x in cnt.values()}) == 1: return 2
        return 1
Bus Fare
-------------
DP + Binary Search:

We find the farthest position we can reach using binary search since dates are increasing. Then, we minimize the cost obtained from the different jumps we can make.
-------------
from bisect import bisect_left
from functools import lru_cache
class Solution:
    def solve(self, days):
        @lru_cache(None)
        def dp(i=0):
            if i == len(days): return 0
            cur_day = days[i]
            j = bisect_left(days, cur_day+1)
            k = bisect_left(days, cur_day+7)
            l = bisect_left(days, cur_day+30)
            return min(dp(j)+2, dp(k)+7, dp(l)+25)
        return dp()
            

Unique Integers in Sorted List
-------------
We start at the beginning of the array (i=0). Since the array is sorted, we can binary search for the rightmost occurence of the number i. In this instance, bisect_right will return the first index for which the number is larger than nums[i], so we will jump to the next distinct number.
-------------
from bisect import bisect_right
class Solution:
    def solve(self, nums):
        i=0
        ans=0
        while i < len(nums):
            i=bisect_right(nums, nums[i])
            ans+=1
        return ans
        

Bomber Man Sequel
-------------
O(N*M):

I stored the enemies you could reach in the current row from any position, and the enemies you could reach in the current column from any position,  then I summed the results from both matrices and returned the max answer.

To avoid re-iterating over the same squares in the same row/col, I emulated an int pointer using a single-position array. While iterating over a row col, I assigned the current pointer to the position, and each time that I met an enemy, I incremented that same pointer. Each time I met a wall, I no longer wanted to modify the previous position, so I reinitialized a new pointer for the future cells.
-------------
class Solution:
    def solve(self, matrix):
        rows={}
        cols={}
        for i in range(len(matrix)):
            cur=[0]
            for j in range(len(matrix[0])):
                if matrix[i][j] == 2:
                    cur[0]+=1
                elif matrix[i][j] == 1:
                    cur=[0]
                rows[(i,j)]=cur
        for j in range(len(matrix[0])):
            cur=[0]
            for i in range(len(matrix)):
                if matrix[i][j] == 2:
                    cur[0]+=1
                elif matrix[i][j] == 1:
                    cur=[0]
                cols[(i,j)]=cur
        ans=0
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if matrix[i][j] == 0:
                    count=rows[(i,j)][0]+cols[(i,j)][0]
                    ans=max(ans,count)
        return ans

Subsequence Picking
-------------
Time complexity: O(n^2) I think, because we build a list of dictionary that have at most n elements.

Inspired by https://leetcode.com/problems/distinct-subsequences-ii/, modified to keep track of the count of subsequences of given length.

We want to minimize the cost of picking k subsequences, where the cost of picking a subsequence is given by the length of the string minus the length of the subsequence. Therefore, we want to pick the longest k subsequences. We need to find out how many subsequences of any given length exists to solve this.

Let's start by ignoring the constraint that says that subsequences must be distinct, how do we find the number of subsequences of different lengths then? Well, we can do this is a dynamic programming fashion, where we start with an empty string as the base case, and then iterate over every character, and counting how many subsequences result from adding the character to all existing subsequences, and not adding it.

This works, as long as there are no duplicates characters. Let's take "aa" for example. At first, we start with the empty string:

"" : {0: 1} (There is one subsequence of length 0)
"a": {0: 1, 1: 1} (We copy the previous state for the case where we don't pick the current character, and add to key+1 for the case where we pick a)
"aa": {0:1, 1: 2, 2: 1} (Here, we count the subsequence "a" twice, we have ["", "a", "a", "aa"])

To avoid duplicates, we can keep track of the last time we saw the current character, and subtract whatever the state was at that point to the current state, so we don't double count subsequences.

Most of the work is done, we just have to pick the k largest subsequences, which will be left as an exercice to the reader, or just look at the code :)

-------------
class Solution:
    def solve(self, S, k):
        dp = [{0:1}]
        last = {}
        for i, x in enumerate(S):
            new=dict(dp[-1])
            for key,v in dp[-1].items():
                if x in last and key in dp[last[x]]:
                    new[key+1]=new.get(key+1,0)-dp[last[x]][key]
                new[key+1]=new.get(key+1,0)+v
            dp.append(new)
            last[x] = i
        tot_cost=0
        for sslen,amount in sorted(dp[-1].items(), reverse=True):
            cost=len(S) - sslen
            count=min(amount,k)
            tot_cost += count*cost
            k-=count
            if k == 0: break
        return tot_cost if k == 0 else -1
Furthest From Origin
-------------
We can take the absolute difference between Ls and Rs to get the distance from the origin, then add ?s to it.
-------------
class Solution:
    def solve(self, s):
        return abs(s.count("L")-s.count("R"))+s.count("?")

Split Product
-------------
DP solution: we try every number between 1 and n as a product, then solve for the remaining sub-problem.

O(n^2), because there are n unique states, and each state has a cost of n because of the loop.
-------------
from functools import lru_cache
class Solution:
    def solve(self, n):
        @lru_cache(None)
        def dp(n):
            if n == 0: return 1
            ans=0
            for i in range(1,n+1):
                ans=max(ans, i*dp(n-i))
            return ans
        return dp(n)

Split List
-------------
For every position in the array, you save the maximum value up to that point, and the minimum value coming after it. For the constraints to be respected, the maximum before the current position must be less than the minimum in the numbers following it.
-------------
class Solution:
    def solve(self, nums):
        mx=[-1e9 for _ in nums]
        mn=[1e9 for _ in nums]
        mx[0] = nums[0]
        mn[-1] = nums[-1]
        for i in range(1,len(nums)):
            mx[i]=max(nums[i],mx[i-1])
        for i in range(len(nums)-2,-1,-1):
            mn[i]=min(nums[i],mn[i+1])
        return any(mx[i]<mn[i+1] for i in range(len(nums)-1))

Latin Square Solver
-------------
Similar to Sudoku Solver, we build a set of used numbers for each rows and each columns, then apply a backtracking approach to the empty cells, trying every possible value, and seeing if we can fill every square.
-------------
class Solution:
    def solve(self, matrix):
        if not matrix: return True
        rows=[set() for _ in matrix]
        cols=[set() for _ in matrix[0]]
        empties=[]
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if matrix[i][j]:
                    if matrix[i][j] in rows[i] or matrix[i][j] in cols[j]: return False
                    rows[i].add(matrix[i][j])
                    cols[j].add(matrix[i][j])
                else:
                    empties.append((i,j))
        def backtrack(x=0):
            if x == len(empties): return True
            i,j = empties[x]
            for val in range(1,len(matrix)+1):
                if val not in rows[i] and val not in cols[j]:
                    rows[i].add(val)
                    cols[j].add(val)
                    if backtrack(x+1): 
                        return True
                    cols[j].remove(val)
                    rows[i].remove(val)
            return False
        return backtrack()

Hop Cost
-------------
From any starting position, we consider all the possible sub problems we can reach, we can either jump [1,dist], or switch lists and jump [1, dist]. We can do dynamic programming because there are overlapping subproblems; for example, we reach the same problem by jumping 1 step twice and making a 2-step jump once.

The base case is when we reach the end of a list, then we just return the value attained.

O(N^2), because there are 2xN unique states to our problem, and for each state we do 2xN calculations.
-------------
from functools import lru_cache
class Solution:
    def solve(self, nums0, nums1, dist, cost):
        lists=[nums0,nums1]
        @lru_cache(None)
        def dp(i=0, cur_list=0):
            if i == len(nums0)-1: return lists[cur_list][i]
            ans=float('inf')
            for j in range(1,dist+1):
                k=i+j
                if k == len(nums0): break
                ans=min(ans, dp(k, cur_list)+lists[cur_list][i])
                ans=min(ans, dp(k, cur_list^1)+lists[cur_list][i]+cost) # switch
            return ans
        a= min(dp(0,0),dp(0,1))
        return a

Grammar Rules
-------------
Since the permitted characters are constrained by the last picked character, we can define a lookup table giving us the allowed characters in function of the last picked character.

Then, we can iterate over the valid characters, and count the number of ways to solve the sub problem with n-1 and setting the last picked character with the current one.

The base case is when we reach an empty string - we have constructed a valid string according to the constraints.
-------------
from functools import lru_cache
MOD=10**9+7
class Solution:
    def solve(self, n):
        if n == 0: return 0
        # Write your code here
        # a -> e
        # e -> a|i
        # i -> !i
        # o -> i|u
        # u -> a
        table = {
            "a": "e",
            "e": "ai",
            "i": "aeou",
            "o": "iu",
            "u": "a",
            None: "aeoui"
        }
        @lru_cache(None)
        def dp(n, last=None):
            if n == 0: return 1
            ans=0
            for c in table[last]:
                ans+=dp(n-1,c)
            return ans% MOD
        return dp(n)
    
Collision Detection
-------------
We can use the "ray-tracing" strategy, described here: http://www.eecs.umich.edu/courses/eecs380/HANDOUTS/PROJ2/InsidePoly.html

From our point (x,y), we trace a line to the left and count the number of segment it intersects. If the number is odd, we must be inside the polygon.

To compute this, we check every segment that includes the y position of our point, and check if it is to the left our of point. To find the x position of the slope at position y,  we need to compute the slope of the segment.

Video explanation: https://www.youtube.com/watch?v=yeOIE1oyV0U
-------------
class Solution:
    def solve(self, polygon, x, y):
        ans=False
        for i in range(len(polygon)):
            x0,y0 = polygon[i]
            x1,y1 = polygon[(i+1)%len(polygon)]
            if not min(y0,y1) < y <= max(y0,y1): continue
            if x < min(x0,x1): continue
            cur_x = x0 if x0==x1 else x0+(y-y0)*(x1-x0)/(y1-y0)
            ans^= x>cur_x
        return ans
Making Change Trequel
-------------
2D dp solution: each row represent the coin currently being tested, each col represents the current amount. Best learned by watching videos on the problem.

Here's my attempt at a video explanation: https://www.youtube.com/watch?v=bV1CvGRu4cg&t=56s
-------------
class Solution:
    def solve(self, denominations, amount):
        dp = [[0]*(amount+1) for _ in denominations]
        for i in range(len(denominations)):
            dp[i][0]=1
        for k in range(1,amount+1):
            for i,d in enumerate(denominations):
                if i > 0: dp[i][k] = dp[i-1][k]
                if k-d >= 0: dp[i][k] += dp[i][k-d]
        return dp[-1][-1] % (10 ** 9 + 7)
                

K-Divisible Sublist
-------------
The sum of a sublist [i:j] can be defined as the prefix sum ending at j minus the prefix sum ending at i.

If we want the sum to be a multiple of k, the sum modulo k must equal 0. 

If the prefix sum modulo k ending at j is equal to the prefix sum modulo k ending at i, it means the sum in between modulo k is equal to 0, so it is a multiple of k.

Thanks to xiao for the insight.
-------------
class Solution:
    def solve(self, nums, k):
        pre=[nums[0]%k]
        for i in range(1,len(nums)):
            pre.append((pre[-1]+nums[i])%k)
        s=set([0])
        for i in range(1,len(nums)):
            if pre[i] in s: 
                return True
            s.add(pre[i-1])
        return False

Wallstreet Bets
-------------
We can keep a monotonic decreasing queue, so that we can check every previous price smaller than the current one by popping of the end of the queue as long as values are smaller than the current one.

O(n) time, O(n) space. Beat that!
-------------
class Solution:
    def solve(self, prices):
        ans=[0 for _ in prices]
        q=[]
        for i,p in enumerate(prices):
            while q and p > q[-1][1]:
                j=q[-1][0]
                ans[j] = i-j
                q.pop()
            q.append((i,p))
        return ans
Partition String
-------------
We find the leftmost occurence and the rightmost occurence for each character.

Then, we consider the range between the leftmost and rightmost occurence of a character an interval. We reduce the problem to the merging overlapping intervals problem.

We do not need to sort the intervals, since i add the intervals in the intervals array according to their order in the string - where they are already ordered.

O(n) time, O(n) space
-------------
class Solution:
    def solve(self, s):
        left={}
        right={}
        for i,c in enumerate(s):
            if c not in left:
                left[c]=i
            right[c]=i
        intervals=[]
        seen=set()
        for c in s:
            if c not in seen:
                seen.add(c)
                intervals.append([left[c],right[c]])
        stk=[]
        for start,e in intervals:
            if not stk or start>stk[-1][1]:
                stk.append([start,e])
            else:
                stk[-1][1]=max(e,stk[-1][1])
        ans=[]
        for start,e in stk:
            ans.append(e-start+1)
        return ans
Distinct Islands
-------------
For every piece of land found, I apply BFS, and add every position of land relative to the first piece of land in a set. 

I convert it to a frozen set, a immutable set, so that we can put the set into sets. The length of the set of islands is our answer.

O(N) time, O(N) space, where N is number of tiles.
-------------
from collections import deque
class Solution:
    def solve(self, matrix):
        def get_neighbors(i,j):
            for ni,nj in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:
                if ni>=0 and nj>=0 and ni<len(matrix) and nj<len(matrix[0]) and matrix[ni][nj]:
                    yield ni,nj
        def bfs(i,j):
            q=deque()
            q.append((i,j))
            rel=set()
            matrix[i][j]=0
            while q:
                ci, cj= q.popleft()
                rel.add((ci-i,cj-j))
                for ni,nj in get_neighbors(ci,cj):
                    matrix[ni][nj]=0
                    q.append((ni,nj))
            return frozenset(rel)
        islands=set()
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if matrix[i][j]:
                    islands.add(bfs(i,j))
        return len(islands)
                    

Kth Missing Number
-------------
Since the array is sorted, we can compare adjacent element to find the number of number missing in between them:

nums[i]-nums[i-1]-1 will give us the count of missing numbers in between the two numbers.

If the number of missing numbers in between two indices is smaller than k, we know that the kth missing number isn't between those two indices, so we remove the difference from k and move on.

Otherwise, we can get the kth missing numbers by counting the offset from the first possible missing numbers, nums[i-1]+1+k.

O(n) time, O(1) space. 

Edit: I think this can be done in O(log n) time.
-------------
class Solution:
    def solve(self, nums, k):
        for i in range(1,len(nums)):
            diff=nums[i]-nums[i-1]-1
            if k >= diff:
                k-=diff
            else:
                return nums[i-1]+k+1
        return nums[-1]+k+1

Number of K-Length Sublists with Average at Least Target
-------------
Knowing that the sublist will always be of length k, if we multiply the target by k, we can solve for the sum instead of the average, since the average is the sum divided by the number of elements.

So, we apply a sliding-window sum, and check if the sum respects the constraint and increment our answer.

O(n) time, O(1) space
-------------
class Solution:
    def solve(self, nums, k, target):
        target*=k
        sum=0
        ans=0
        for i,n in enumerate(nums):
            if i>=k:
                sum-=nums[i-k]
            sum+=n
            if i>=(k-1):
                if sum>=target:
                    ans+=1
        return ans
ZigZag Path
-------------
We recursively travel the tree, returning two values for each node: 
1. How far can we get zigzaging to the left child from the current node
2. How can we get zigzaging to the right from the current node

When we bubble up, we can only check how far the left child can zigzag to the right to respect zigzag constraint, and how far the right child can zigzag to the left.

We include the left zigzag of the left child and the right zigzag of the right child because it is possible the longest possible zigzag does not start at the root.

O(n) time, O(depth of the tree, n?) space
-------------
class Solution:
    def solve(self, root):
        ans=0
        def rc(node):
            nonlocal ans
            if not node: 
                return 0,0
            l1,r1=rc(node.left)
            l2,r2=rc(node.right)
            ans=max(ans, 1+l2, 1+r1,l1,r2)
            return 1+r1, 1+l2
        rc(root)
        return ans
            
Hop Cost Sequel
-------------
To find the optimal answer, we can treat this problem as a graph, where each node we can visit from the current one are i+1, i-1, and all nodes with same value.

Then, to find the minimum steps, we explore all nodes we can reach within 1 step, all nodes we can reach within 2 steps, etc. Otherwise known as BFS (breadth-first search).

So when we first encounter the last index of the array, we can return early, and if we meet an index that was already treated, we know that we cannot get a better answer by visiting it with a larger step count.

We can delete the strongly connected components composed of same values when we visit them, because we know we won't be able to get a better answer by revisiting the positions.

O(n) time because we visit each index once, O(n) space because we store all seen indexes.
-------------
from collections import deque,defaultdict
class Solution:
    def solve(self, nums):
        val_idx = defaultdict(list)
        for i,x in enumerate(nums):
            val_idx[x].append(i)
        def get_neighbors(i):
            val=nums[i]
            if i>0:
                yield i-1
            if i < len(nums)-1:
                yield i+1
            for j in val_idx[val]:
                yield j
            del val_idx[val]
        seen=set()
        q=deque()
        seen.add(0)
        q.append(0)
        ans=0
        while q:
            for _ in range(len(q)):
                cur=q.popleft()
                if cur == len(nums)-1: return ans
                for nei in get_neighbors(cur):
                    if nei not in seen:
                        seen.add(nei)
                        q.append(nei)
            ans+=1
        return -1
            

Multiset Sum
-------------
Top-down DP solution:
For each number, we iterate over multiples of that number. As long as we can fit nums[i] into k, we keep trying to take more, and trying to solve the subproblem with i+1 and k minus the amount of nums[i] we took.

O(n*k) time, O(n) space
-------------
from functools import lru_cache
class Solution:
    def solve(self, nums, k):
        @lru_cache(None)
        def dp(i,k):
            if k == 0: return 1
            if i == len(nums): return 0
            ans=0
            j=0
            while j*nums[i]<=k:
                ans+=dp(i+1, k-j*nums[i])
                j+=1
            return ans
        return dp(0, k)

Adding Time
-------------
Built-in solutions baby! Using Python's datetime package, you can specify the format of the string and modify it to your will.
-------------
from datetime import datetime, timedelta
format="%I:%M%p"
class Solution:
    def solve(self, s, n):
        return (datetime.strptime(s,format)+timedelta(minutes=n)).strftime(format).lower()

Making List Values Equal
-------------
Since we can select a subset, numbers don't need to be adjacent.

Therefore, the constraining factor of this problem will be incrementing the min up to the max value of the array.

O(n) time, O(1) space
-------------
class Solution:
    def solve(self, nums):
        return max(nums)-min(nums)
Finding Binary Search in a String
-------------
We can store the positions for each character in the input string in a dictionary.

Then, we can treat this as a graph traversal problem, where the next possible nodes are the next character in the string "binarysearch", where the position of the character comes after the current one and respects the constant difference constraint.
-------------
from collections import defaultdict
class Solution:
    def solve(self, s):
        chrs=defaultdict(list)
        for i,c in enumerate(s):
            chrs[c].append(i)
        target="binarysearch"
        def dfs(i=0, last=None, diff=None):
            if i == len(target): 
                return True
            c=target[i]
            for pos in chrs[c]:
                if last and pos < last: continue
                if not diff or pos-last==diff:
                    if dfs(i+1, pos, pos-last if last else None): 
                        return True
            return False
        return dfs()
Making Pairwise Adjacent Sums Small
-------------
We iterate over the array, reducing the 2nd element from the pair as much as needed, and doing so will minimize the subtraction needed for the next pair including it. 

We make sure that we don't go under zero because the operation only applies to positive values.

O(n) time, O(1) space
-------------
MOD=10**9 + 7
class Solution:
    def solve(self, nums, k):
        ans=0
        for i in range(0,len(nums)-1):
            sm = nums[i]+nums[i+1]
            diff=max(sm-k,0)
            nums[i+1]-=diff
            if nums[i+1]<0:
                nums[i+1]=0
            ans+=diff
        return ans % MOD

Sum of Digit Paths in a Tree
-------------
We traverse the tree, keeping a prefix result of the number over the current node. Each time we meet a node, we shift the previous digits by multiplying by 10 and adding the current value. If we reach a leaf (no left or right child), we return the result, otherwise we return the sum of the results of both children (if they exist).
-------------
class Solution:
    def solve(self, root):
        def dfs(node,pre):
            cur=pre*10+node.val
            if not node.left and not node.right: return cur
            return sum(dfs(c,cur) for c in (node.left,node.right) if c)
        return dfs(root,0)
        

Repeated K-Length Substrings
-------------
One-line version of ruby's answer - we can sum the booleans directly so if they are true, they are equal to one.

Otherwise the logic is the same, we use a counter to count the frequencies of each k-length substring.

Time complexity: O(n*k), because slicing takes k steps and we repeat it up to n times
Space complexity: O(n*k), because we will store n substrings of length k
-------------
from collections import Counter
class Solution:
    def solve(self, s, k):
        return sum(v>1 for v in Counter(s[i:i+k] for i in range(len(s)-k+1)).values())

String Clockwise Shift
-------------
(ord(c2)-ord(c1))%26 will automatically compute the right shift needed, as long as your language supports negative modulos.
We check if the sum of the necessary shifts are smaller than k.
-------------
class Solution:
    def solve(self, a, b, k):
        return k>=sum((ord(c2)-ord(c1))%26 for c1,c2 in zip(a,b))
        

Partition List to Pairs that Are Divisible by K
-------------
We count all numbers modulo k. Let's say a number has a remainder of 2 (mod 5), well it has to be matched to a number that has a remainder of 3 (mod 5) to complete the 5. So, each remainder must be equal to its complement (mod k), except when the remainder is 0 or half of k, then it matches with itself so it must be divisible by 2.

O(n) time, O(n) space
-------------
from collections import Counter
class Solution:
    def solve(self, nums, k):
        c=Counter()
        for n in nums:
            c[n%k]+=1
        for n,v in c.items():
            if n == 0 or n == k/2:
                if v&1: 
                    return False
            else:
                if c[-n%k]!=v: 
                    return False
        return True

Minimum Number of Operations to Make Lists Increasing
-------------
DP solution, where the tracked state is the position and whether we swapped the previous items:
We try the sub problem where we don't swap (if it respects the constraints of the problem - a[i]>a[i-1] and b[i]>b[i-1]),
and the sub problem where we swap (again, if it respects the constraints).

We take the minimum output from both sub problems.

O(n) time, O(n) space
-------------
from functools import lru_cache
class Solution:
    def solve(self, a, b):
        @lru_cache(None)
        def dp(i=0,prevswapped=False):
            if len(a)==i:
                return 0
            elif i == 0:
                # We are free to do whatever on first index
                return min(dp(i+1), 1+dp(i+1,True))
            else:
                preva=a[i-1]
                prevb=b[i-1]
                if prevswapped:
                    preva,prevb=prevb,preva
                # forced to swap, otherwise constraints are not respect
                if a[i]<=preva or b[i]<=prevb: 
                    return 1+dp(i+1,True)
                else:
                    # Try not swapping
                    ans=dp(i+1)
                    # If constraints are still respected, try swapping
                    if a[i]>prevb and b[i]>preva:
                        ans=min(ans,1+dp(i+1,True))
                    return ans
        return dp()
Concatenated Sums
-------------
For each number, let's consider the number of times it will be at the bottom part of the concatenation. Since it will be the bottom for every number in the array, we can add the number times the length of the array to clear that part.

Now, let's consider how many times the current number is the top part of the concatenation. Since its value varies in function of the length of the bottom part, we can make a Counter of the lengths of each number, as to have buckets for each length with their associated frequency. 

Since a 32-bit integer has at most 2 billion as a value, we know that the length of the number is at most 10, so our algorithm stays linear. We iterate over each length, then consider how it shifts the current number: 10^(len) * num will give us the value of the top part.

Time: O(n)
Space: O(1), the counter will have at most 10 entries for same reason as explained above.

-------------
from collections import Counter
class Solution:
    def solve(self, nums):
        cnt=Counter([len(str(n)) for n in nums])
        ans=0
        for i,n in enumerate(nums):
            ans+=n*len(nums) #bottom
            # top
            for l,freq in cnt.items():
                ans+=freq*(n*10**l)
        return ans

Longest Substring with Character Count of at Least K
-------------
Instead of trying to build an optimal solution, we can try taking the full string, and cutting it where the characters are of unsufficient frequency. Using a counter, we can iterate over the string, and if the frequency of the current character is less than k, we can recursively try to solve on the left part.

When all characters in the substring are of sufficient frequency, we can return the length of the current string.
-------------
from collections import Counter
class Solution:
    def solve(self, s, k):
        def rc(lst):
            c=Counter(lst)
            acc=[]
            ans=0
            valid=True
            for x in lst:
                if c[x]<k:
                    valid=False
                    ans=max(ans,rc(acc))
                    acc=[]
                else:
                    acc.append(x)
            
            if valid:
                return len(acc)
            else:
                ans=max(ans,rc(acc))
                return ans
        return rc(list(s))
Lossy Run-Length Encoding
-------------
We apply a sliding window of size k on the substring we want to remove. To compute the cost (the length of the resulting run-length encoded string), we can take the cost of the prefix before the substring, and the suffix after the substring, and merging the interior part if the characters are the same.

To do this, I compute a prefix array that contains two informations: the cost of all previous characters and the length of the current run, so we can combine the lengths if the character ending the prefix or the character starting the suffix is the same.
-------------
class Solution:
    def solve(self, s, k):
        def prefix(s):
            pre=[[0,0]] # [past_cost, current_run_length]
            last=None
            for c in s:
                if c == last:
                    pre.append([pre[-1][0], pre[-1][1]+1])
                else:
                    pre.append([pre[-1][0]+cost_fn(pre[-1][1]), 1])
                last=c
            return pre
        pre=prefix(s)
        suf=prefix(s[::-1])[::-1]
        ans=float('inf')
        for i in range(len(s)-k+1):
            j=i+k
            left,midl = pre[i]
            right,midr = suf[j]
            cost=left+right
            c1=s[i-1] if i>0 else None
            c2=s[j] if j<len(s) else None
            if c1 == c2:
                cost+=cost_fn(midl+midr)
            else:
                cost+=cost_fn(midl)+cost_fn(midr)
            ans=min(ans,cost)
        return ans
        
def cost_fn(l):
    if l == 0:
        return 0
    if l == 1:
        return 1
    else:
        return len(str(l))+1
Binary Search Tree Validation
-------------
We add a lower and higher bound that every node must respect. When we go left, we reduce our higher bound so that every node to the left must be smaller. When we go right, we augment our lower bound so that every node to the right must be larger.

O(n) Time
O(log n) Space, because a new stack frame is added each recursive call equal to the height of the tree.
-------------
class Solution:
    def solve(self, root,lo=float("-inf"), hi=float("inf")):
        return not root or lo<root.val<hi and self.solve(root.left, lo, root.val) and self.solve(root.right, root.val,hi)

Binary Matrix Leftmost One
-------------
For each row, we binary search for the leftmost occurence of a 1. We take the minimum answer, or return -1 if no answer is found.

O(R*log(C)) time
O(1) space
-------------
from bisect import bisect_left
INF=float('inf')
class Solution:
    def solve(self, matrix):
        ans=INF
        for r in matrix:
            i=bisect_left(r,1)
            if i <len(r):
                ans=min(ans,i)
        return ans if ans < INF else -1

Costly Flight of Stairs
-------------
DP solution, where the optimal way to reach dp[i] is `$dp[i]+ \min_{x=1..k} dp[i-x]$`
If we were to iterate over every predecessor of dp[i], the complexity would be of O(n*k), because we would have to iterate over the k previous values.
But, using a min-queue, we can reduce this complexity down to O(n), because we can lookup the min in a sliding window in constant time.

O(n) time, O(k) space
-------------
from collections import deque
class Solution:
    def solve(self, stairs, k):
        q=deque([(stairs[0],0)]) # (cost, i)
        for i in range(1,len(stairs)):
            while i-q[0][1]>k:
                q.popleft()
            curcost=q[0][0]+stairs[i]
            while q and curcost<=q[-1][0]:
                q.pop()
            q.append((curcost,i))
        return q[-1][0]
Column Flips to Maximum Number of Equal Rows
-------------
The only rows that can all be ones or zeroes are the rows that are either exactly the same or the inverse of each other. So, we can put rows into buckets, identified to the values relative to the first value. That way, rows that are identical or the inverse will go into the same bucket. 

Example:
0101 -> will go into bucket {0,2}, because those are the indices of the values equal to the first value
1010 -> will go into bucket {0,2}, because those are the indices of the values equal to the first value
1100 -> will go into bucket {0,1}
0011 -> will go into bucket {0,1}

The answer is the size of the largest bucket of rows. In the example, we have two buckets of size two, so the answer is two.

O(nm) time, O(nm) space
-------------
from collections import Counter
class Solution:
    def solve(self, matrix):
        c=Counter()
        for row in matrix:
            s=set()
            for i,v in enumerate(row):
                if v==row[0]:
                    s.add(i)
            c[frozenset(s)]+=1
        return max(c.values())

Minimum Size of Two Non-Overlapping Intervals
-------------
We can build a suffix array containing the minimum cost (defined by the width of the interval) to the right of the current position. Then, for every interval, we can binary search for the position using the end, to find the left most interval that doesn't overlap with the current one. Then, we compute the sum of the current interval and the min to the right of the end and minimize the result.

O(N Log N) time
O(N) space
-------------
from bisect import bisect_left
class Solution:
    def solve(self, intervals):
        intervals.sort()
        starts=[s for s,_ in intervals]
        minr=[float("inf") for _ in intervals]
        def cost(interval):
            return interval[1]-interval[0]+1
        minr[-1]=cost(intervals[-1])
        for i in range(len(intervals)-2,-1,-1):
            minr[i]=min(cost(intervals[i]), minr[i+1])
        ans=float("inf")
        for s,e in intervals:
            j = bisect_left(starts,e+1)
            if j<len(starts):
                ans=min(ans, cost([s,e])+minr[j])
        return ans if ans < float("inf") else 0

Gene Mutation Groups
-------------
We can make strongly connected component by iterating over every gene, then every letter removal. Take "ACGT" and "AGGT" for example, then will end up in the same bucket with key (left="A", right="GT") when the second letter is removed.

Then, we can apply a simple DFS to count the connected groups, where every neighbor belong to the same strongly connected components as the current gene. Each time we encounter a gene we haven't explored, we have found a new group, then we mark as seen all genes belonging to the same group.

O(N*L) time, N being the number of genes and L being the length of the genes
O(N) space
-------------
from collections import Counter,defaultdict
class Solution:
    def solve(self, genes):
        comp=defaultdict(list)
        for gene in genes:
            for i in range(len(gene)):
                left=gene[:i]
                right=gene[i+1:]
                comp[(left,right)].append(gene)
        seen=set()
        ans=0
        def dfs(gene):
            for i in range(len(gene)):
                left=gene[:i]
                right=gene[i+1:]
                for nei in comp[(left,right)]:
                    if nei not in seen:
                        seen.add(nei)
                        dfs(nei)
        for gene in genes:
            if gene not in seen:
                ans+=1
                seen.add(gene)
                dfs(gene)
        return ans

Remove Sublist to Reach Equilibrium
-------------
We can build a prefix array and a suffix array, both counting the equilibrium before a given index and after a given index. Equilibrium is decremented when n<k and incremented when n>k. 

So, for a sublist removal to attain an equilibrium of 0, we need a sublist nums[i:j] where prefix[i] == -suffix[j], so that the prefix is the inverse of the suffix which makes them balance out.

To do this, we can iterate over every number, and mark its index in a dictionary. Then, we check if we have ever seen -n in the dictionary, if so, it means that we have a prefix that balances out with the current suffix. It is a potential answer, which we minimize to find the result. 

O(n) time
O(n) space
-------------
class Solution:
    def solve(self, nums, k):
        if sum((n<k)*-1+(n>k)*1 for n in nums) == 0: return len(nums)
        def prefix(l):
            pf=[0]
            for n in l:
                inc=0
                if n>k: inc=1
                if n<k: inc=-1
                pf.append(pf[-1]+inc)
            pf.pop()
            return pf
        left=prefix(nums)
        right=prefix(nums[::-1])[::-1]
        seen={}
        ans=0
        for i in range(len(right)-1,-1,-1):
            seen[right[i]]=i
            n=left[i]
            if -n in seen:
                j=seen[-n]
                ans=max(ans,len(nums)-(j-i+1))
        return ans
Minimum Number of Flips to Have Alternating Values
-------------
We could repeat the input string twice, and use a sliding window using the size of the original string. 

To find the cost of the current string, we looked at the cost of first character in the window. If it is 1, the expected optimal string is 101010101 and so on, to avoid any cost. It if starts by 0, the expected string is 01010101..., so if we xor the current bit with the expected one we can get the current cost.

Now what happens when we shift our window? If the new starting bit is the same as the old one, it means the optimal string is shifted so we need to inverse the cost by doing k-cost-1. -1, because the start is no longer counted, and inverted because every wrong bit is now a correct one, and every correct one becomes wrong. If the new starting bit is not the same as the old starting bit, the optimal string is not changed, because 010101... shifted by one to the left is 101010...

When we add a bit, we compare it to the start. If the offset from the start is even, it means the current bit must be equal, otherwise they must be different.

O(n) time
O(n) space
-------------
class Solution:
    def solve(self, s):
        k=len(s)
        s=s+s
        start=0
        cost=0
        ans=1e9
        for i in range(len(s)):
            if i-start>=k:
                ans=min(ans,cost)
                start+=1
                if s[start]==s[start-1]:
                    cost=k-cost-1
            offset=i-start
            if offset&1:
                if s[i]==s[start]:
                    cost+=1
            else:
                if s[i]!=s[start]:
                    cost+=1
        ans=min(ans,cost)
        return ans

Partition Lists to Make Sorted List
-------------
We store the position of the numbers when they are sorted in a dictionary of queues. Then, we iterate of the numbers and create intervals between their original position and their sorted position. If we want the final array to be sorted, we know that we have to sort the range including the original position of the number and its sorted target position.

Then we can apply a regular overlapping intervals merging algorithm. The answer is the remaining count of non-overlapping intervals.

Note: Dealing with duplicates is particularly tricky, and is the reason I am using a deque for each position. For each leftmost occurrence of the number, we use the leftmost position in the sorted array to minimize potential overlap. 

O(N log N) time
O(n) space
-------------
from collections import defaultdict, deque
class Solution:
    def solve(self, nums):
        sorted_pos=defaultdict(deque)
        for i,n in enumerate(sorted(nums)):
            sorted_pos[n].append(i)
        intervals=[]
        for i,n in enumerate(nums):
            x = sorted_pos[n].popleft()
            if i<x:
                a,b=i,x
            else:
                a,b=x,i
            intervals.append([a,b])
        stk=[]
        for s,e in intervals:
            if not stk or s>stk[-1][1]:
                stk.append([s,e])
            else:
                stk[-1][1]=max(stk[-1][1],e)
        return len(stk)
            
Team Voting
-------------
To be able to compare candidates in a lexicographic fashion, we can give them an array each of length equal to the number of candidates. A[0] will be the number of first places, A[1] the number of second places, etc.

After building the arrays for each candidates, we can sort the candidates based on their arrays and their associated letters in case of ties.
-------------
from collections import defaultdict
class Solution:
    def solve(self, votes):
        cnt=len(votes[0])
        cand=defaultdict(lambda:[0]*cnt)
        for v in votes:
            for i,c in enumerate(v):
                cand[c][i]+=1
        return "".join(sorted(cand.keys(),key=lambda x:(cand[x],-ord(x)),reverse=True))
                

Sum of Three Numbers Sequel
-------------
O(n^2) solution.

We sort the number, so we know what to do when we are smaller or bigger than the target.

When we are smaller, we know we have to increment one of the numbers, otherwise we need to reduce one of our numbers.

That is the logic behind this algo: Select one number, and then use two pointers for the next two numbers: the smallest value and the greatest value after i. Compute the sum, and if we are greater than target, reduce greatest value and if smaller, increment smaller number.
-------------
class Solution:
    def solve(self, nums, target):
        nums.sort()
        ans=1e9
        for i in range(len(nums)):
            j=i+1
            k=len(nums)-1
            while j<k:
                s=nums[i]+nums[j]+nums[k]
                if s<=target:
                    ans=min(ans,target-s)
                    j+=1
                else:
                    ans=min(ans,s-target)
                    k-=1
        return ans

Word Concatenation
-------------
We store every word in a set for constant time lookup. Then, to find out if a word is a concatenation, we try cutting the string in half at every position, giving us a prefix and a suffix. If both the prefix and the suffix are in the set of words, or if they are a concatenation of words, the current word is a concatenation. We memoize the recursive function to avoid recomputation for the same words, and overlapping substrings.

`$O(n\times m^2)$` time (n words, m iterations per word with cost of m because of slicing)
`$O(n\times m)$` space
-------------
from functools import lru_cache
class Solution:
    def solve(self, words):
        seen=set(words)
        @lru_cache(None)
        def is_concat(word):
            for i in range(1,len(word)):
                left=word[:i]
                right=word[i:]
                if all(ss in seen or is_concat(ss) for ss in (left,right)):
                    return True
            return False
        return sum(is_concat(w) for w in words)
            

Longest Concatenated String
-------------
We can solve the problem in linear time by iterating through the words backwards, and adding them in buckets based on their first letter.
When we reach a word, we check in the bucket corresponding to its last letter, and store the number of words at that moment in the bucket. This way, if we add words that are before the word in the list, they will not be considered.

Then, we can apply a DP algorithm on the graph. For each word i, we look at the longest concatenation we can make from its children, where the last character is equal to the first one. We don't have to worry about cycles, since we know that only words coming after the current one are neighbors.

O(n) time, but with a high coefficient, because the first letter than can 26 values.
O(n) space
-------------
from collections import defaultdict
from functools import lru_cache
class Solution:
    def solve(self, words):
        adj=defaultdict(int)
        ltrs=defaultdict(list)
        for i in range(len(words)-1,-1,-1):
            cur=words[i]
            last=cur[-1]
            adj[i]=len(ltrs[last])
            ltrs[cur[0]].append(i)
                
        @lru_cache(None)
        def dp(i, first):
            cur=words[i]
            ans=float("-inf")
            if cur[-1]==first:
                ans=len(cur)
            last=cur[-1]
            for nei in range(adj[i]):
                ans=max(ans, len(cur)+dp(ltrs[last][nei],first))
            return ans
        return max(0,max(dp(i,words[i][0]) for i in range(len(words))))
Repeated String Replacement to Target
-------------
For the transformation to be possible there must be only one character mapped to each character, so the number of unique mappings must be equal to the number of unique characters in S. 

O(n) time
O(n) space
-------------
class Solution:
    def solve(self, s, t):
        return len(set(s)) == len(set(zip(s,t)))

Counting Maximal Value Roots in Binary Tree
-------------
We can recursively get the maximum descendant for each node, and while bubbling up, we check if the current node is greater than the max of its descendants, and increment our answer if so.

O(n) time
O(h) space, height of tree
-------------
class Solution:
    def solve(self, root):
        ans=0
        def rc(node):
            if not node: return -1e9
            nonlocal ans
            l=rc(node.left)
            r=rc(node.right)
            if node.val >= l and node.val >= r:
                ans+=1
            return max(node.val,l,r)
        rc(root)
        return ans

Shortest Path by Removing K Walls
-------------
This is like a regular BFS, with the twist being with how we handle our seen set.

Instead of just storing seen coordinates in a set, we now store the number of walls left when we reached that position. Knowing that when we BFS, the minimal cost path will be explored first, the only way to find a more optimal path when re-exploring a same path is to have more wall removals in reserve. 
-------------
from collections import deque
class Solution:
    def solve(self, matrix, k):
        def adj(i,j):
            for ni,nj in [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]:
                if 0<=ni<len(matrix) and 0<=nj<len(matrix[0]):
                    yield ni,nj
        seen={}
        seen[(0,0)]=0
        q=deque([(0,0,0,0)]) # (cost,walls, i,j)
        while q:
            cost,wall_removed,i,j = q.popleft()
            if i == len(matrix)-1 and j == len(matrix[0])-1:
                return cost
            for ni,nj in adj(i,j):
                new_wall = wall_removed+matrix[ni][nj]
                if new_wall>k: 
                    continue
                if (ni,nj) in seen and seen[(ni,nj)]<=new_wall:
                    continue
                seen[(ni,nj)]=new_wall
                nxt=(cost+1, new_wall,ni,nj)
                q.append(nxt)
        return -1
Subsequence Concatenation to Target
-------------
The first step is checking if the problem is solvable. The only constraint we need to respect is that every character from target is in source. A single character is a valid sub sequence, so it makes it possible to solve it as so.

Then to solve the problem, we can use a common pattern that comes up in some subsequence pattern: for every position in source, we store the position of the next closest occurence of any character. This way, we can jump to it in constant time.

After, we iterate over the target. For each character, we ask: "What is the closest right occurence of this character?". If it doesn't show up to the right of the current position, we need to start a new subsequence starting from index 0.

O(n) time but with high coefficient because of the creation of n dictionaries with at most 26 elements.
O(n) space, for storing the dictionaries.
-------------
class Solution:
    def solve(self, source, target):
        a=set(source)
        b=set(target)
        if a&b < b: 
            return -1
        nxt=[None for _ in source]
        nxt[-1]={}
        for i in range(len(source)-1,-1,-1):
            if i < len(source)-1:
                nxt[i]=nxt[i+1].copy()
            nxt[i][source[i]]=i
        ans=1
        i=0
        j=0
        while j < len(target):
            if i == len(source):
                i=0
                ans+=1
            c=target[j]
            if c not in nxt[i]:
                ans+=1
                i=0
            i=nxt[i][target[j]]+1
            j+=1
        return ans
            

Create Palindrome After Deleting at Most K Characters
-------------
We can start from the center of a potential palindrome, and then each time we have equal characters, we return dp(i-1, j+1), and if we have non-equal characters we return min(dp(i-1,j), dp(i,j+1))+1 to simulate removing either the left or the right character. When we reach the edge of the string we have to remove all the remaining characters on the other side.
-------------
from functools import lru_cache
class Solution:
    def solve(self, s, k):
        @lru_cache(None)
        def dp(i,j):
            if i<0 and j>=len(s):
                return 0
            if i<0:
                return len(s)-j
            if j>=len(s):
                return i+1
            if s[i]==s[j]:
                return dp(i-1, j+1)
            else:
                return min(dp(i-1, j), dp(i,j+1))+1
        return any(dp(i,i)<=k or dp(i,i+1)<=k for i in range(len(s)))

Connect Sticks
-------------
We can treat this problem as a graph problem, where each endpoint is a node and each stick is an edge. We can only use each stick once, so we store the index of the stick in a set, and can only use sticks that aren't in this set.

The longest path problem is known to be NP-Hard:  https://en.wikipedia.org/wiki/Longest_path_problem. Therefore, we are forced to check all possible paths to find the longest one, making this solution exponential relative to the number of edges.

Not sure about time complexity, I think its O(a^n), where a is the average number of neighbors for each vertex and n is the maximum length of each path, which is the number of endpoints.

O(n) space complexity, for storing graph and seen sticks.
-------------
from collections import defaultdict

class Solution:
    def solve(self, sticks):
        adj=defaultdict(set)
        endpoint={end for stick in sticks for end in stick}
        for i,(s,e) in enumerate(sticks):
            adj[s].add((i,e))
            adj[e].add((i,s))
            
        def dfs(end,seen=set()):
            return max(1+dfs(nei, seen|{i}) if i not in seen else 0 for i,nei in adj[end])
        return max(dfs(end) for end in endpoint)

Frogger
-------------
I think test cases are weak cause I didn't even need to memoize my function, or maybe this problem has few overlapping subproblems.

Basically create a set of all stones to look up if a position is valid in constant time, then starting from position 1 and jump=0, recursively try jumping each valid jump that are greater than 0 then solve recursively.

To analyse complexity, we need to figure out how many different values our last jump can have.

Since we can increase our jump by one each subproblem to explore a new subproblem, our largest jump can be represent by the arithmetic sequence 1+2+3+4+... = target

n(n+1)/2 = target
n(n+1) = 2 * target
n^2 + n = 2 * target
~ n = sqrt(target)

So i think time complexity is O(n*sqrt(n)) = O(n),
O(n) space
-------------
class Solution:
    def solve(self, stones):
        target=stones[-1]
        valid=set(stones)
        def bt(i, last=0):
            if i == target: 
                return True
            return any(
                i+jump in valid and bt(i+jump, jump) 
                for jump in (last-1, last, last+1) 
                if jump > 0
            )
        return bt(0)

Candy Race Sequel
-------------
Top-down dynamic programming solution:

We try each possible move, taking 1,2 or 3 candy, and subtract the optimal answer for the subproblem starting after our move. 
Since the subproblem starting after our move is the subproblem where Lawrence is starting, each points he makes reduces our score. 

To be winning, we need a greater score than lawrence, and since we subtract lawrence's score, we can check if we have a relative score greater than zero.

O(n) time
O(n) space
-------------
from functools import lru_cache
class Solution:
    def solve(self, nums):
        @lru_cache(None)
        def dp(i=0):
            if i >= len(nums): return 0
            return max(
                nums[i]-dp(i+1),
                nums[i]+nums[i+1]-dp(i+2) if i < len(nums)-1 else 0,
                nums[i]+nums[i+1]+nums[i+2]-dp(i+3) if i < len(nums)-2 else 0,
            )
        return dp()>0

Maximum Non-Adjacent Tree Sum
-------------
Classic dynamic programming problem, where our recurrence relation is defined by whether we use the current node or not.

If we use the current nodes, we cannot use the children therefore we have to jump over them.
If we do not use the current node, we are free to use the childrens in our final answer. 

There is O(2n) unique states (number of nodes times 2 states for the boolean), so this top-down algorithm runs in linear time.

This is the same as the problem House Robber III on Leetcode which I covered in this video: 
https://www.youtube.com/watch?v=1RAF6tW_Acs
-------------
from functools import lru_cache
class Solution:
    def solve(self, root):
        @lru_cache(None)
        def dp(node, free=True):
            if not node: return 0
            ans = 0
            if free:
                ans = node.val + dp(node.left, False) + dp(node.right, False)
            ans = max(ans, dp(node.left, True) + dp(node.right, True))
            return ans
        return dp(root)
Squeezed List
-------------
Alternative syntax I learned about today. Using:

```python
head,*body,tail=nums
```
You can use easily extract the first and last value of the nums. If nums is of length two, the body will be empty so we can replace it by a 0.
-------------
class Solution:
    def solve(self, nums):
        ans=[nums[::]]
        while len(nums)>1:
            head,*nums,tail=nums
            nums=nums or [0]
            nums[0]+=head
            nums[-1]+=tail
            ans.append(nums[::])
        return ans

Least Frequently Used Cache
-------------
*I recommend looking at the problem **LRU Cache** first, as this problem builds on similar ideas.*

For our LFU Cache class, we keep track of four important properties:

- The capacity.
- A dictionary where each unique frequency maps to a LRU Cache of values (equivalent to a doubly-linked list).
- The minimum frequency. We only need to store one single value because the only case where we evict the least frequent value is when we insert a value not present in our cache and at that point we can replace the minimum frequency with a frequency of 0.
- A dictionary enabling use to lookup each values according to the key.

## Let's look at the first simple step: how to we `get` a value from our LFU Cache?

**Simple!**

We look in our `key_to_node` dictionary. If the key is present, we retrieve the value from the underlying node. 
The more complex part is: **how do we update the frequency of the node?** I think this has nothing to do with retrieving the value, so let's abstract it away in another method and deal with it later.

## How do we `set` a value?

**A little bit harder, but still manageable!**

If the value is already set, we retrieve the node and overwrite its value and frequency. Since we decided earlier to deal with updating frequencies in a different method, we can once again deal with it later.

**What if the value is not present?**

Then this is the case where we possibly have to evict the least frequent value. Let's once again abstract this away in another method and worry with the implementation later. For now, let's just say: 
```python
if len(self.key_to_node) == self.capacity:
    # do the thing!
```
After we have handled our capacity problem, we can freely insert our value. To do that, we create a new linked list node, we insert in our `key_to_node` dictionary and in the appropriate LRU Cache in `self.cache`. Also, this newly inserted node becomes the least frequent element, so we set `self.min_frequency` to zero.

## Nooooo you can't just abstract every hard part of the problem and pretend you solved it!

Fine. Let's implement the methods we ignored until now: `update_frequency(node)` and `evict_least_frequently_used()`

## How do we update the frequency of a node?

***Note**: This part is important. Remember this and you can solve this problem with your eyes closed*

The first step is to remove the node from the LRU cache (doubly-linked list) it currently resides in. When doing so, we have to check if we leave the LRU Cache empty - if it is the case, it is possible that we must increment the minimum frequency. To know if our minimum frequency changes, we look if the LRU cache that we are leaving empty has a key equal to the minimum frequency of the LFU cache. If it is the case, we know that the current node was the least frequent, and we must increment the minimum frequency.

Then we can insert the node to the LRU Cache of the next frequency, and call it a day.

## How do we evict the least frequent node?

We pop the last value off the LRU Cache with a frequency equal to `self.min_frequency`. Thankfully, the min_frequency is overwritten after this method, because evicting the least frequent node leaves the min_frequency invalid for a few lines of code (monkaS).

-------------
from dataclasses import dataclass
from collections import defaultdict


@dataclass
class LLNode:
    key: int = -1
    val: int = -1
    freq: int = -1
    prev: LLNode = None
    next: LLNode = None
    
    
class LinkedList:
    def __init__(self):
        """
        Thanks to bunny for this trick!
        We can pad the doubly link list
        with dummy nodes so we don't have
        any edge cases to deal with 
        when inserting/removing nodes
        """
        self.head = LLNode()
        self.tail = LLNode()
        self.head.next = self.tail
        self.tail.prev = self.head
        self.size = 0
    
    def insert(self, node):
        left, right = self.head, self.head.next
        node.prev, node.next = left, right
        left.next, right.prev = node, node
        self.size += 1
        return node
        
    def remove(self, node):
        left, right = node.prev, node.next
        left.next, right.prev = right, left
        node.prev, node.next = None, None
        self.size -= 1
        return node
        
    def pop(self):
        if self.size == 0:
            raise Exception("Cannot pop from empty list")
        return self.remove(self.tail.prev)
        
        
class LRUCache:
    def __init__(self):
        self.list = LinkedList()
        
    def insert(self, node):
        self.list.insert(node)
        
    def remove(self, node):
        self.list.remove(node)
        
    def evict_least_recent(self):
        return self.list.pop()
        
    @property
    def size(self):
        return self.list.size
        
        
class LFUCache:
    def __init__(self, capacity):
        """
        For each frequency, we use a 
        Least Recently Used cache to handle
        with the case where we have multiple entries
        of the same frequency.
        """
        self.cache = defaultdict(LRUCache)
        self.capacity = capacity
        self.min_frequency = 0
        self.key_to_node = {}

    def get(self, key):
        if key not in self.key_to_node:
            return -1
        node = self.key_to_node[key]
        self.update_frequency(node)
        return node.val

    def set(self, key, val):
        if key in self.key_to_node:
            node = self.key_to_node[key]
            node.val = val
            self.update_frequency(node)
        else:
            if len(self.key_to_node) == self.capacity:
                self.evict_least_frequent()
            node = LLNode(key=key, val=val, freq=0)
            self.key_to_node[key] = node
            self.cache[node.freq].insert(node)
            self.min_frequency = 0
            
        
    def update_frequency(self, node):
        self.cache[node.freq].remove(node)
        if self.cache[node.freq].size == 0 and node.freq == self.min_frequency:
            self.min_frequency += 1
        node.freq += 1
        self.cache[node.freq].insert(node)
        
    def evict_least_frequent(self):
        node = self.cache[self.min_frequency].evict_least_recent()
        del self.key_to_node[node.key]
        
Distinct Subsequences
-------------
Let's forget the constraint that our subsequences must be unique for a bit. For every character in our subsequence, we double the number of possible subsequences, because we can either use a character or not use it.

The problem is that we have overlap between subsequences when we have duplicate characters. Let's take for example, "aca".

First we start with empty string, "". It counts as one possibility.
For the first character "a", we can either take it or not, so our possibilities become "" or "a", 2 possibilites.
For the character "c", we can either take it or not, so our possibilities become "", "a", "c", "ac", 4 possibilites.
For the last character "a", we can either take it or not, so our possibilities become "", "a", "c", "ac", "a", "aa", "ca", "aca", 8 possibilites.

But we notice the overlap between the two "a" possibilities. The trick is to remember the last time we seen the character, and subtract the number of possibilities when we saw that character, as to get rid of the overlapping possibilities.

We subtract one at the end to remove the initial empty subsequence.
-------------
MOD = 10**9+7
class Solution:
    def solve(self, s):
        last = {}
        a = [1]
        for i,c in enumerate(s):
            prev = a[-1] * 2
            if c in last:
                prev -= a[last[c]]
            a.append(prev % MOD)
            last[c] = i
        return a[-1]-1
Matrix Rectangular Sums
-------------
The key to this problem is to compute 2D prefix sum. To compute the prefix sum from coordinates (0,0) to (i,j), in O(n^2), we can use the following recurrence relation: 

`prefix[i][j] = prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1]`

The sum of the rectangle is the sum of the rectangle above it and to the left of it, minus the overlapping part. It helps to use a defaultdict to avoid handling edges cases with out of bound coordinates. 

Then, using the prefix sum, we can cut out the sum of a square section of the matrix in constant time by taking the prefix sum to the bottom left coordinate of the square, removing everything to the left and above of the square, and re-adding the part we subtracted twice, following the inclusion-exclusion principle. 
-------------
from collections import defaultdict
class Solution:
    def solve(self, matrix, k):
        pre=defaultdict(int)
        R,C = len(matrix), len(matrix[0])
        for i in range(R+k):
            for j in range(C+k):
                pre[(i,j)] = pre[(i-1,j)] \
                + pre[(i,j-1)] \
                - pre[(i-1,j-1)]
                if i<len(matrix) and j < len(matrix[0]):
                    pre[(i,j)] += matrix[i][j]
        return [[
                pre[(i+k, j+k)] \
                + pre[(i-k-1, j-k-1)] \
                - pre[(i+k, j-k-1)] \
                - pre[(i-k-1, j+k)]
                for j in range(C)
            ] for i in range(R)]
                
Minimum Initial Value for Positive Prefix Sums
-------------
We need the lowest value in the prefix sum array to be >= 1, so we find the minimum, negate it and add one.
-------------
class Solution:
    def solve(self, nums):
        pf = [0]
        for n in nums:
            pf.append(pf[-1]+n)
        return -min(pf) + 1
Pattern to Word Bijection
-------------
Bijection means that for every element in group a, there is only one element in group b and vice-versa.

So, the number of elements in group a must equal the number of elements in group b which must equal the unique number of edges between the two groups.
-------------
class Solution:
    def solve(self, s, p):
        words = s.split()
        return len(set(words)) == len(set(p)) == len(set(zip(words, p)))
Task Run
-------------
We keep track of the last time we saw the current task type using a dictionary. 

When we see a task, we check if we already saw the current type by doing a dictionary lookup. If we didn't, we can just increase answer by one.

IF we already saw the task, we compute the distance between the current task and the old one. If its less than k we need to wait the difference. We offset the position i by the total waited time. 
-------------
class Solution:
    def solve(self, tasks, k):
        last = {}
        ans = waited = 0
        for i, t in enumerate(tasks):
            if t not in last:
                ans += 1
            else:
                diff = i - last[t] + waited
                if diff <= k:
                    wait = k - diff + 1
                    waited += wait
                    ans += wait
                ans += 1
            last[t] = i + waited
        return ans
Non-Overlapping Pairs of Sublists
-------------
We group valid chunks of number together using the groupby function.

Then, to pick our two sublists as stated in the problem, we have two possibilities:
- We can pick a sublist from a previous chunk
- We can pick a sublist from the current chunk

The first case is the simplest to handle. We can accumulate the number of possible sublists to the left of the current one with the formula n * (n+1) // 2, where n is the length of a chunk. For example, for a chunk of length 5, we have 1 sublist of length 5, 2 sublists of length 4, 3 sublists of length 3, and so on. The result is the arithemic series 1 + 2 + 3 + ... + n which equals n * (n+1) // 2. Then we take the product of the number of possibilities for the current chunk times the number of possible chunks to the left.

For the second case, we iterate over every split point in our chunk, so for a chunk of length 5, we can split it in the following ways : (1,4), (2,3), (3,2), (4,1). We compute the number of possibilities for the left and right part and take the product. We must also remove some overlap in the left part, because all the possibilities of length 1 are a subset of the possibilities of sublists of length 2. 
-------------
from itertools import groupby
MOD = 10 **9 + 7
class Solution:
    def solve(self, nums, k):
        def sublist_cnt(n):
            return n * (n+1) // 2
            
        grps = []
        for valid, grp in groupby(nums, key=lambda x: x>=k):
            if valid:
                grps.append(len(list(grp)))
                
        left = 0
        ans = 0
        for n in grps:
            sc = sublist_cnt(n)
            ans = (ans + (left * sc)) % MOD
            for i in range(1,n):
                right = n - i
                ans += (sublist_cnt(i) - sublist_cnt(i-1)) * sublist_cnt(right) % MOD
            left += sc
        return ans % MOD
Cheapest Bus Route
-------------
We can use dijkstra's algorithm, with the nuance in how we handle our seen nodes. We need to keep track of which bus we were on when we visited a node, as results may vary depending on that.
-------------
from heapq import heapify, heappop, heappush
from collections import defaultdict
class Solution:
    def solve(self, connections):
        start = 0
        target = max(max(y,x) for y,x,_ in connections)
        
        adj = defaultdict(list)
        for f,t,id in connections:
            adj[f].append((t,id))
            
        hp = [(0, start, -1)] # (cost, cur_pos cur_bus)
        seen = defaultdict(set)
        
        while hp:
            cost, cur_pos, cur_bus = heappop(hp)
            if cur_pos == target:
                return cost
            if cur_bus in seen[cur_pos]:
                continue
            seen[cur_pos].add(cur_bus)
                
            for nex_pos, nex_bus in adj[cur_pos]:
                next_cost = cost
                if nex_bus != cur_bus:
                    next_cost += 1
                heappush(hp, (next_cost, nex_pos, nex_bus))
            
        return -1
Range Query on a List
-------------
This problem can be used an exercise to learn about segment trees, even if the time complexity is worse than prefix sums. Segment trees are useful for general range queries using any aggregating operator (sum, min, max, product, ...). 

## How it works

The list of numbers becomes the bottom level of the segment tree. Then every pair of neighbors gets combined into a new node in the upper level. Each level will have half the number of nodes as the previous one, so we can say that the height of this tree will be log(n), where n is the number of items in our input.

We can represent this tree using an array where index 1 is the root of the tree, and its children can be accessed the following way: 

|  OOP representation | Array representation  |  
|---|---|
|  node  |   array[i]| 
|  node.left | array[i * 2]  | 
|  node.right | array[i * 2 + 1]
The reason this works is because each level has twice as many nodes as the previous ones, so doubling the index skips a level. 
This same logic is used for a heap, and can be used for any nearly complete tree.

**To build the tree**, we create a new array double the size of our original list of numbers. The first half will be generated nodes, while the second half will be the original numbers sitting on the last level of the tree. We iterate backwards on the first half, combining the children of the current node like mentioned above:
```python
self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]
```
Every node contains the sum of all the nodes under it. We can use this fact to query a range of the tree in log(n) time.

**To query a range**, we must figure out the minimal number of nodes to combine to get our answer. For this approach, we start on the index of the original elements of the list by offsetting by half the list:
```
m = self.l + i
n = self.l + j
```
Then the logic goes as follows. 

For the left bound **m**:
- If we are the left child of our parent, we do not need to add the current value as the parent contains both the left and the right child, so we can just go up in the tree.
- If we are the right child of our parent, we cannot use our parent because it includes the left child which isn't in the range query. Therefore, we add the current value to the result, and move to our parent's right neighbor. 

We do the opposite for the right bound **n**:
-  If we are the right child of our parent, we do not need to add the current value as the parent contains both the left and the right child, so we can just go up in the tree.
- If we are the left child of our parent, we cannot use our parent because it includes the right child which isn't in the range query. Therefore, we add the current value to the result, and move to our parent's left neighbor. 

It is possible that we reach the same node with both bounds. Given that they are equal, the node will be either a left child or a right child but never both, therefore it will only be counted once. After that, the bounds will cross and the loop will exit.

This cover the basics of the wonderful segment tree. Its true power comes with additional features such as adding new elements or lazy propagation.
-------------
class SegmentTree:
	def __init__(self, nums):
		self.l = len(nums)
		self.tree = [0] * self.l + nums
		for i in range(self.l - 1, 0, -1):
			self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]

	def sum_range(self, i, j):
		m = self.l + i
		n = self.l + j
		ans = 0
		while m <= n:
			if m % 2 == 1:
				ans += self.tree[m]
				m += 1
			m //= 2
			
			if n % 2 == 0:
				ans += self.tree[n]
				n -= 1
			n //= 2
		return ans
		
class RangeSum:
    def __init__(self, nums):
        self.st = SegmentTree(nums)
    def total(self, i, j):
        return self.st.sum_range(i, j-1)
        
Range Query on a List - Mutable
-------------
I suggest doing the immutable version of this problem first, and look at my segment tree solution for it. 

We can reuse the code, but this time we have an addition: the update function. When we modify a value, we invalidate all the ancestors of that node. As we have seen before, we can get the parent of the node by dividing its index by two. So while we haven't reached the root, we add the difference of our new value to the node and go to the parent. 


-------------
class MutableRangeSum:
    def __init__(self, nums):
        self.l = len(nums)
        self.tree = [0] * self.l + nums
        for i in range(self.l - 1, 0, -1):
            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]

    def total(self, i, j):
        m = self.l + i
        n = self.l + j - 1
        ans = 0
        while m <= n:
            if m % 2 == 1:
                ans += self.tree[m]
                m += 1
            m //= 2
            
            if n % 2 == 0:
                ans += self.tree[n]
                n -= 1
            n //= 2
        return ans
            

    def update(self, idx, val):
        m = self.l + idx
        diff = val - self.tree[m]
        while m:
            self.tree[m] += diff
            m //= 2

